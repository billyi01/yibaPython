[
["index.html", "YiBaPython 《易爸親子共學Python編程語言》", " YiBaPython 《易爸親子共學Python編程語言》 作者：易爸 日期：2020-08-29 緣起： 我們家的YY和QQ之前玩過scratch、code.org，想讓他們開始試試python，於是嘗試編製一套「不囉嗦的」教材，用以親子共學。 "],
["anaconda發行.html", "1 Anaconda發行 1.1 何謂Anaconda 1.2 Anaconda安裝 1.3 Jupyter 1.4 Spyder 1.5 學習要點（Anaconda發行） 1.6 自我練習（Anaconda發行）", " 1 Anaconda發行 1.1 何謂Anaconda 開源軟件常有不同模組套件間的相互依賴（interdependence）等問題，因此有人就將較為相容者整理為某個發行（distribution），例如Linux就有Ubuntu、Debian、CentOS、Fedora等發行，而Python一樣也有多個發行，其中一個常見的就是Anaconda。 1.2 Anaconda安裝 這在網上已有很多說明，此處列舉幾個供參，基本上照著做就可以了： Windows10 安裝 Anaconda 環境 Python教學第0章-Anaconda 完整安裝教學及搭建 vscode 開發環境 Windows環境 安裝教學（Anaconda）從0到1 Anaconda介紹及安裝教學 Anaconda 簡易入門 1.3 Jupyter 1.3.1 何謂Jupyter Jupyter是一種互動式記事本（interactive notebook），使用它可以立即得到（互動）操作結果。 1.3.2 開啟Jupyter 此處以Windows為例： 開始＞Anaconda3，選取「Anaconda Navigator」或直接點擊「Jupyter Notebook」 如上步驟選取「Anaconda Navigator」此處再點「Jupyter Notebook」 開啟如下畫面，新增（new）一個「Python 3」的筆記 新的空白筆記畫面如下 1.3.3 Jupyter教學 這裡找到一篇貼文最詳盡使用指南：超快上手 Jupyter Notebook供參，如果沒能全部理解內容也沒關係，先感覺一下它大概怎麼用就行了。 1.4 Spyder 1.4.1 何謂Spyder Spyder是一個整合開發環境（Integrated Development Environment，IDE），使用它可以幫助瞭解物件內容。 1.4.2 開啟Spyder 此處以Windows為例： 開始＞Anaconda3，選取「Anaconda Navigator」或直接點擊「Spyder」 如上步驟選取「Anaconda Navigator」此處再點「Spyder」 開啟後的畫面如下； 1.4.3 Spyder教學 這裡找到一篇貼文從零開始帶你認識spyder開發環境供參，如果沒能全部理解內容也沒關係，先感覺一下它大概怎麼用就行了。 1.5 學習要點（Anaconda發行） 學會安裝Python的Anaconda發行。 學會開啟Jupyter並能新增python記事本。 學會開啟Spyder並能新增py腳本文件。 1.6 自我練習（Anaconda發行） 嘗試安裝Python的Anaconda發行。 開啟Jupyter，新增一個python的記事本，參考前段Jupyter教學內容，操作一下玩玩看。 開啟Spyer，新增一個test.py腳本文件，參考前段Spyder教學內容，瀏覽一下各窗格對應功能。 "],
["哈囉世界hello-world.html", "2 哈囉，世界！（Hello, World!） 2.1 何謂字串 2.2 列出字串 2.3 何謂註解 2.4 加上註解 2.5 尋找幫助 2.6 學習要點（哈囉，世界！） 2.7 自我練習（哈囉，世界！）", " 2 哈囉，世界！（Hello, World!） 2.1 何謂字串 把幾個文字符號串接在一起，就形成了字串（string），字串頭尾兩端要用引號（可以是單引號'或雙引號\"），這樣電腦才知道它是字串，例如：'被單引號包圍的字串'或\"被雙引號包圍的字串\"。 2.2 列出字串 我們先嘗試讓電腦列出一些文字，例如：\"哈囉，世界！\"這句，請嘗試執行以下陳述。 print(&quot;哈囉，世界！&quot;) ## 哈囉，世界！ 沒錯，print( )是一個函式，用來列出它括弧中的文字的，你可以在( )中放入字串，例如：\"我要列出這個句子\"（注意：字串被引號包圍著），然後執行以下的陳述就可以將該字串列出。 print(&quot;我要列出這個句子&quot;) ## 我要列出這個句子 2.3 何謂註解 註解（comment）就是給人類寫給自己看的說明文字，電腦會忽略它而不進行任何動作。 註解有二種： 單排註解：每一橫列在#之後的文字都被視為註解； 多排註解：夾在三個引號\"\"\"之間的文字都被視為註解。 2.4 加上註解 # 我是一個註解，從橫排最左開始就是，不會被執行。 print(&quot;我不是註解，是要列出的字串&quot;) # 我是另一個註解，從橫排中間才開始，也不會被執行。 ## 我不是註解，是要列出的字串 2.5 尋找幫助 如果英文能力尚可的話，可以直接調用help( )函式，將想瞭解的主題放到函式括弧內，例如： print(help(print)) # 列出「print」的幫助內容。 ## Help on built-in function print in module builtins: ## ## print(...) ## print(value, ..., sep=&#39; &#39;, end=&#39;\\n&#39;, file=sys.stdout, flush=False) ## ## Prints the values to a stream, or to sys.stdout by default. ## Optional keyword arguments: ## file: a file-like object (stream); defaults to the current sys.stdout. ## sep: string inserted between values, default a space. ## end: string appended after the last value, default a newline. ## flush: whether to forcibly flush the stream. ## ## None print(help(help)) # 列出「help」的幫助內容。 ## Help on _Helper in module _sitebuiltins object: ## ## class _Helper(builtins.object) ## | Define the builtin &#39;help&#39;. ## | ## | This is a wrapper around pydoc.help that provides a helpful message ## | when &#39;help&#39; is typed at the Python interactive prompt. ## | ## | Calling help() at the Python prompt starts an interactive help session. ## | Calling help(thing) prints help for the python object &#39;thing&#39;. ## | ## | Methods defined here: ## | ## | __call__(self, *args, **kwds) ## | Call self as a function. ## | ## | __repr__(self) ## | Return repr(self). ## | ## | ---------------------------------------------------------------------- ## | Data descriptors defined here: ## | ## | __dict__ ## | dictionary for instance variables (if defined) ## | ## | __weakref__ ## | list of weak references to the object (if defined) ## ## None 2.6 學習要點（哈囉，世界！） 學會使用print( )函式列出想要的文字。 學會使用#、'''、\"\"\"為代碼加上註解。 學會使用help( )查找所需的幫助內容。 2.7 自我練習（哈囉，世界！） 自己設計一段文字，例如：「我叫『苦連天』，每天過著幸福快樂的日子」，試著讓電腦列出，並加入你自己的註解。 使用help( )隨意查找一些自己有興趣的關鍵字，看能找到什麼有趣的內容。 "],
["基本數據型別basic-data-types.html", "3 基本數據型別（Basic Data Types） 3.1 整數（integer） 3.2 浮點（floating point） 3.3 複數（complex） 3.4 布林（boolean） 3.5 字串（string） 3.6 學習要點（基本數據型別） 3.7 應用情境（基本數據型別） 3.8 尋找幫助（基本數據型別）", " 3 基本數據型別（Basic Data Types） 3.1 整數（integer） …, -3, -2, -1, 0, 1, 2, 3, … 這些就是整數（integer）。 print(1) ## 1 print(2) ## 2 3.1.1 列出整數 我們可以用print( )陳述將其列出，在( )中，不必再加引號，因為「整數」不是「字串」，它們的「數據型別」是不同的。 記住，整數不加引號，字串要加引號。 print(3) ## 3 print(&quot;3&quot;) ## 3 上面二個陳述，都得到3這個結果，看不出「整數」與「字串」有何不同啊？到底差異何在？ 3.1.2 何謂數據型別 電腦有幾個基本的數據型別，整數（integer）是其中之一，字串（string）也是其中之一，我們可以用type( )查看物件的型別。 print(type(3)) ## &lt;class &#39;int&#39;&gt; 結果中的&lt;class 'int'&gt;表示3是一個int（整數）。 print(type(&quot;3&quot;), type(&quot;三&quot;)) # 同時列出&quot;3&quot;和&quot;三&quot;的型別 ## &lt;class &#39;str&#39;&gt; &lt;class &#39;str&#39;&gt; 以上陳述的結果為&lt;class 'str'&gt;表示\"3\"、\"三\"都是str（字串），因為兩者都被引號所包圍。 3.1.3 算術運算子（arithmetic operator） 常用的算術運算子至少包括了： 算數運算子 說明 + 加 - 減 * 乘 / 除 // 商數 % 餘數 ** 次方 上表的算數運算子皆為中置（infix）運算子，在其前後二側的整數則稱為運算元（operand），運算元與運算子整體合稱為運算式或表達式（expression）。 3.1.4 整數運算 我們來看看幾個實際的整數算術運算式例子…… print(1 + 2) # 加 ## 3 print(3 - 4) # 減 ## -1 print(5 * 6) # 乘 ## 30 print(8 / 2) # 除 ## 4.0 print(7 // 3) # 商數 ## 2 print(7 % 3) # 餘數 ## 1 print(3 ** 2) # 次方 ## 9 3.1.5 自我練習（整數算數運算） 打開Jupyter或Spyder。 嘗試用整數進行各種算數運算。 3.2 浮點（floating point） 前面所學的整數只構成了數線上等距離散的點，那數線上其它非整數的點要怎麼表示呢？例如：半個蘋果、四分之三條香蕉、八公升的牛奶由五個人來分。這種情形就要用小數點來表示，因為各個數值的小數點位置不一定相同，小數點不固定而是浮動的，故稱為「浮點」。 print(1 / 2) # 半個蘋果 ## 0.5 print(3 / 4) # 四分之三條香蕉 ## 0.75 print(8 / 5) # 八公升牛奶分配給五個人 ## 1.6 細心的同學在前面整數運算式的例子中就可發現8 / 2的結果不是4（整數）而是4.0（浮點），因為python自動將除的結果型別改為浮點了。 print(type(8 / 2)) ## &lt;class &#39;float&#39;&gt; 好奇的你可能會問：「在數學上，1完全等於1.0、2完全等於2.0`，為什麼在電腦上還要特別區分為不同的型別呢？」這是因為電腦的記憶體及儲存媒介所存放的紀錄，只用「0」和「1」來表示，這一大串的0和1的意義，要靠型別區分才能解釋。就好像「大丈夫」出現在中文及日文語境下的意思不同，又好比 The soldier decided to desert his dessert in the desert.（該士兵決定將他的點心捨棄在沙漠裡）其中desert前後意思不同。 3.2.1 浮點運算 前面所述的算術運算子，也都可以用在浮點型別的運算元上。 3.2.2 型別轉換（整數、浮點） 整數和浮點這二者可以互相轉換，要轉成整數用int( )，要轉成浮點用float( )。 print(int(2.5)) # 浮點轉換為整數，原有小數部分將被移除 ## 2 print(type(int(2.5))) # 浮點轉換為整數，確認改成整數型別 ## &lt;class &#39;int&#39;&gt; print(type(float(3))) # 整數轉換為浮點，確認改成浮點型別 ## &lt;class &#39;float&#39;&gt; 3.2.3 自我練習（整數浮點算數運算、型別轉換） 打開Jupyter或Spyder。 嘗試用整數與浮點進行各種算數運算。 使用type( )函式，查看運算元與運算結果的型別。 嘗試在整數與浮點間雙向進行型別轉換，看能不能找出一些規律，在哪些情況下是符合自己預期的？哪些情況下不像是自己預期的？ 3.3 複數（complex） 一個複數包括了實數與虛數，虛數部分以j表示，在對負值取平方根時產生，以後學校會教，現在可以暫時不去管它。 3.4 布林（boolean） 布林型別有二種值：True（真）與False（假）；通常是比較運算的結果。 3.4.1 比較運算子（comparison operator） 常用的比較運算子有： 比較運算子 說明 == 等於 != 不等於 &gt; 大於 &lt; 小於 &gt;= 大於等於 &lt;= 小於等於 注意，python判斷是否相等用==（要用二個等號）而不是數學上通用的=（只用一個等號），我們來看看幾個實際的比較運算式例子…… print(1 == 2) # 等於 ## False print(3 != 4) # 不等於 ## True print(5 &gt;= 6) # 大於等於 ## False print(7 &lt;= 8) # 小於等於 ## True 3.4.2 邏輯運算子（logical operator） 一個或多個布林值，還可以進行邏輯運算，邏輯運算子有： 邏輯運算子 說明 作用 and 且 前後二個運算元都為真的話，結果為真 or 或 前後二個運算元只要一個為真，結果為真 not 非 前置運算子，將真的運算元變假，假的變真 直接看實例更容易理解邏輯運算： print(True and True, # 「且」的例子 True and False, False and True, False and False) ## True False False False print(True or True, # 「或」的例子 True or False, False or True, False or False) ## True True True False print(not True, # 「非」的例子 not False) ## False True 3.4.3 運算先後順序 假如運算式中含有多個運算子，這些運算子的先後順序，並不是從最左依序執行到最右，有的運算子再更右邊但可能比在左邊的另一些運算子更先被執行，下表中先被執行的排在前面，越後面就越晚被執行。： 運算子 說明 ( ) 括弧 ** 次方，中置算術運算子 +x, -x 正號、負號，前置運算子 *, /, //, % 乘、除、商數、餘數，中置算術運算子 +, - 加、減，中置算術運算子 ==, !=, &gt;, &gt;=, &lt;, &lt;= 中置比較運算子 not 非，邏輯運算子 and 且，邏輯運算子 or 或，邏輯運算子 因為括弧( )是最優先的，如果順序不容易記住的話，就自己將要先執行的運算用括弧圍住即可，例如： print( 2 + 3 * 4) # 因為先乘除再加減，python先執行 3 * 4 = 12，再執行 2 + 12 = 14 ## 14 print((2 + 3) * 4) # 使用括弧就可以先做 2 + 3 = 5，再做 5 * 4 = 20 ## 20 3.4.4 型別轉換（布林、整數、浮點） 布林也能和整數與浮點互相轉換，要轉成布林用bool( )。 print(bool()) # 無輸入值為假 ## False print(bool(0)) # 整數0為假 ## False print(bool(1)) # 整數1為真 ## True print(bool(0.0)) # 浮點零值為假 ## False print(bool(0.1)) # 非零浮點為真 ## True print(bool(&quot;&quot;)) # 空字串為假 ## False print(bool(&quot; &quot;)) # 非空字串為真 ## True print(int(True)) # 真值為整數1 ## 1 print(int(False)) # 假值為整數0 ## 0 print(float(True)) # 真值為浮點1.0 ## 1.0 print(float(False)) # 假值為浮點0.0 ## 0.0 3.4.5 自我練習（比較運算、邏輯運算、型別轉換） 打開Jupyter或Spyder。 嘗試用整數與浮點進行各種比較運算。 嘗試用比較運算結果再進行邏輯運算。 適當使用type( )函式，查看運算元與運算結果的型別。 嘗試在整數、浮點、布林三者間進行型別轉換，看能不能找出一些規律，在哪些情況下是符合自己預期的？哪些情況下不像是自己預期的？ 3.5 字串（string） 3.5.1 字串運算 在python中，字串也可以使用算術運算子的「加」（接續）和「乘」（重複），像這樣： print(&quot;Pen&quot; + &quot;Pineapple&quot; + &quot;Apple&quot; + &quot;Pen&quot;) # 將四個單詞接續起來 ## PenPineappleApplePen print(&quot;Apple&quot; * 2) # 將這個單詞重複二次 ## AppleApple print(&quot;Pen&quot; + &quot;Pine&quot; + 2 * &quot;Apple&quot; + &quot;Pen&quot;) # 先乘再加，先重複再接續 ## PenPineAppleApplePen 在python中，字串也可以使用比較運算子的「大於」和「小於」，像這樣： print(&quot;A&quot; &gt; &quot;z&quot;, &quot;Z&quot; &lt; &quot;a&quot;) ## False True print(&quot;Dog&quot; &gt; &quot;Cat&quot;, &quot;Apple&quot; &lt; &quot;Banana&quot;) ## True True 3.5.2 型別轉換（字串、整數、浮點） 字串也能和整數、浮點及布林互相轉換，要轉成字串用str( )。 print(str()) # 無輸入值得空字串（而非空白字符） print(str(1)) # 輸入整數得整數字串 ## 1 print(str(1.0)) # 輸入浮點得浮點字串 ## 1.0 print(str(True)) # 輸入布林真值為真值字串 ## True print(str(False)) # 輸入布林假值得假值字串 ## False print(int(&quot;1&quot;)) # 整數字串轉為整數 ## 1 print(int(&quot;3.14&quot;)) # 帶小數的字串不能轉為整數，錯誤！ ## Error in py_call_impl(callable, dots$args, dots$keywords): ValueError: invalid literal for int() with base 10: &#39;3.14&#39; ## ## Detailed traceback: ## File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt; print(float(&quot;3.14&quot;)) # 帶小數點的字串轉為浮點 ## 3.14 print(float(&quot;1,234.5&quot;)) # 字串轉為浮點，字串不得帶有撇節，錯誤！ ## Error in py_call_impl(callable, dots$args, dots$keywords): ValueError: could not convert string to float: &#39;1,234.5&#39; ## ## Detailed traceback: ## File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt; 3.5.3 自我練習（混合四種型別三種運算、四種型別轉換、調整運算執行順序） 打開Jupyter或Spyder。 嘗試字串的算術運算與比較運算，後者再接邏輯運算。 適當使用type( )函式，查看運算元與運算結果的型別。 嘗試在整數、浮點、布林、字串四者間進行型別轉換，看能不能找出一些規律，在哪些情況下是符合自己預期的？哪些情況下不像是自己預期的？ 混合使用包括整數、浮點、布林、字串四種型別，進行包括算術、比較、邏輯三種運算，使用括弧強制改變各運算子的執行順序，看結果是否符合自己預期。 3.5.4 字串方法 方法（methods）就是適用於某型別或類別的函式（functions），要簡單地區別這二者，可看它們對某物件的用法，假設物件名為object，函式名為function，方法名為method，物件是東西像是名詞，函式或方法是動作像是動詞： 函式用法：function(object)，「做動作在物件上，物件被做了什麼動作」。 方法用法：object.method()，「讓物件發起作用，物件做了什麼動作」。 函式用於字串舉例如下： # len( )指length，是個回報長度的函式，物件（字串）放在括弧內，len( )會回報該物件的長度。 print(len(&#39;Dog&#39;), len(&#39;Duck&#39;), len(&#39;Apple&#39;), len(&#39;Banana&#39;)) ## 3 4 5 6 print(max(&#39;Hello, World!&#39;)) # 列出最大的字符。 ## r print(min(&#39;Hello, World!&#39;)) # 列出最小的字符。 字串方法很多，例示如下： print(&#39;hElLo, wOrLd!&#39;.capitalize()) # capitalize( )：首字改成大寫。 ## Hello, world! print(&#39;hElLo, wOrLd!&#39;.upper()) # upper( )：全部改成大寫。 ## HELLO, WORLD! print(&#39;hElLo, wOrLd!&#39;.lower()) # lower( )：全部改成小寫。 ## hello, world! print(&#39;hElLo, wOrLd!&#39;.swapcase()) # swapcase( )：大寫改小寫，小寫改大寫。 ## HeLlO, WoRlD! print(&#39;Hello, World!&#39;.count(&#39;o&#39;)) # count( )：回報某字串（此處為「o」）出現幾次。 ## 2 print(&#39;Hello, World!&#39;.find(&#39;o&#39;)) # find( )：回報某字串（此處為「o」）最先出現位置（從0算起），找不到的話回報「-1」。 ## 4 print(&#39;Hello, World!&#39;.index(&#39;o&#39;)) # index( )：回報某字串（此處為「o」）最先出現位置（從0算起），找不到就丟出錯誤信息。 ## 4 print(&#39;Hello, World!&#39;.rfind(&#39;o&#39;)) # find( )：回報某字串（此處為「o」）最後出現位置（從0算起），找不到的話回報「-1」。 ## 8 print(&#39;Hello, World!&#39;.rindex(&#39;o&#39;)) # index( )：回報某字串（此處為「o」）最後出現位置（從0算起），找不到就丟出錯誤信息。 ## 8 print(&#39;Hello, World!&#39;.replace(&#39;Hello&#39;, &#39;Hi&#39;)) # replace( )：字串替代，此處用Hi替代Hello。 ## Hi, World! print(&#39; Hello, World! &#39;.strip()) # strip( )：消除字串前後空白。 ## Hello, World! print(&#39;Hello, World!&#39;.zfill(20)) # zfill( )：在字串左側補0至指定長度（此處為20）。 ## 0000000Hello, World! 3.5.5 自我練習（字串方法） 打開Jupyter或Spyder。 將學過的每個字串方法，至少用自己的例子執行三次，看看與自己的預期是否相同。 3.6 學習要點（基本數據型別） 瞭解「整數、浮點、布林、字串」四種型別。 學會使用type( )查看物件型別。 學會使用int( )、float( )、bool( )、str( )等函式，能在不同型別間進行轉換。 瞭解「算術運算」、「比較運算」、「邏輯運算」用在哪種場合或情境，能掌握各個運算符號（運算子）的具體使用方法。 學會使用多種字串方法，並能自行舉例說明。 3.7 應用情境（基本數據型別） 要把字串“3.14”轉換成為整數3，請問要怎麼做？ 3.8 尋找幫助（基本數據型別） 前面已經學過了如何利用help( )函式輸入關鍵字使其回報相關內容，這裡列示了一些與本章所列的關鍵字，如有興趣可視需要自己執行看看。因為執行結果很長很佔篇幅，這裡就不列出了。 print(help(type)) print(help(int)) print(help(float)) print(help(bool)) print(help(str)) "],
["變項variables.html", "4 變項（Variables） 4.1 何謂變項 4.2 為何要用變項 4.3 指派注意事項 4.4 變項命名規則 4.5 學習要點（變項） 4.6 自我練習（變項）", " 4 變項（Variables） 4.1 何謂變項 變項，就是給物件「起名字、取綽號、貼標籤」裡的「名字、綽號、標籤」，讓物件有了「稱呼」。要怎麼給呢？就用數學中的等號=來給（只用一個等號，如果用了二個，就是比較運算子的「等於」），這個給的動作叫做「指派」（assign），讓某個名稱和某個物件之間建立了指涉關係。 指派運算子=的左右二側意義不同，它只能將右側的物件指派到左側名稱，而不能反過來做。具體看實例更容易瞭解： my_int = 1 my_float = 3.14 my_bool = True my_str = &quot;Hi&quot; print(my_int, my_float, my_bool, my_str) ## 1 3.14 True Hi 以上my_int、my_float、my_bool、my_str就是變項，因為項目所指內容物件是可以改變的，就像「小花」這個名字，它現在指小狗，將來可能就指小貓，所以稱為變項，又因為在應用上這些名稱經常指涉數值（整數、浮點），又常被稱為變數。 變項內容怎麼變呢？對原來的名字再指派別的內容即可，比如我們把my_int、my_float內容對調，把my_bool、my_str內容對調，對調的陳述方式是「a, b = b, a」，再列出它們的值，觀察一下結果，看它們內容是否變了？ my_int, my_float = my_float, my_int my_bool, my_str = my_str, my_bool print(my_int, my_float, my_bool, my_str) ## 3.14 1 Hi True 4.2 為何要用變項 用一個稱呼代表複雜的東西非常方便，尤其是要對它進行重複操作時，讓計算過程簡潔明瞭。 pi = 3.14159265358979323846264338327950288419716939937510 a = 2 b = 3 c = 5 d = 7 print(pi, pi * a, pi * b, pi * c, pi * d) ## 3.141592653589793 6.283185307179586 9.42477796076938 15.707963267948966 21.991148575128552 試想，前例中如沒有用pi這個變項，只能直接鍵入數字的話，是不是很麻煩又容易出錯？ 4.3 指派注意事項 不同的編程語言，指派內涵可能不同，在python的指派是一種「指涉」或「參照」（reference）而非「賦值」，還是看實例比較好瞭解，以下用到id( )這個函式，用來識別物件「身分」的，每個物件都有它獨特的身分證號（id值）。 a = &quot;apple&quot; b = a c = &quot;apple&quot; print(id(a), id(b), id(c)) ## 660307184 660307184 660307184 發現到了嗎？上例中a, b, c三者的id是相同的，它們雖然名字不同，但其實是同一個物件。就像家中寵物，爸爸叫牠小拐、媽媽叫牠小怪、孩子叫牠小乖，但其實是同一隻。 4.4 變項命名規則 不是任何文字組合都可當作變項名稱，變項命名是有規則的，先掌握一些簡單的就行： 可以組合「大寫字母、小寫字母、數字、底線」。 首字限制只用「字母」，不用「數字」，一般主要使用小寫。 區分大寫小寫，例如：「Egg、egg」被視為二個不同變項。 4.5 學習要點（變項） 理解為何使用變項。 知道怎麼命名變項。 熟悉變項指派運算。 4.6 自我練習（變項） 打開Jupyter或Spyder。 將學過的每個數據型別，用變項來表示。 以各變項作為運算元，配合使用「算術運算子」、「比較運算子」、「邏輯運算子」，構造不同的運算式，看結果是不是自己預期的那樣，有讓人意外的結果嗎？ "],
["基本彙集型別basic-collection-types.html", "5 基本彙集型別（Basic Collection Types） 5.1 元組（tuple） 5.2 串列（list） 5.3 集合（set） 5.4 字典（dictionary） 5.5 巢式彙集（nested collection）", " 5 基本彙集型別（Basic Collection Types） 我們已經學了基本數據型別，包括：整數、浮點、布林、字串等，但它們都是「個別」、「單一」的值，如果想處理「多個」值的話，就要將這些值放在一起形成「彙集」（Collection）。彙集有很多形式，以下介紹：元組（tuple）、串列（list）、集合（set）、字典（dictionary）。 5.1 元組（tuple） 5.1.1 元組建構 用tuple( )函式或直接用小括弧( )，將一個或多個物件放入即可。 在直接使用小括弧的情況下，若只放入一個物件，則要在該物件之後加上,逗點才行。 empty_t = ( ) # 用小括弧來建構元組，這是一個空的元組，命名為empty_t，類別為tuple，因為裡面沒有東西，所以長度為0。 print(type(empty_t), len(empty_t)) ## &lt;class &#39;tuple&#39;&gt; 0 one = (1) # 只用小括弧，就是整數1。 one_t = (1,) # 用小括弧，整數1之後加個逗號，就是含有一個整數1的元組。 print(type(one), type(one_t)) ## &lt;class &#39;int&#39;&gt; &lt;class &#39;tuple&#39;&gt; seasons_t = (&quot;春&quot;, &quot;夏&quot;, &quot;秋&quot;, &quot;冬&quot;) # 建構一個內含「四季」字串的元組，命名為seasons_t，長度為4。 print(seasons_t, len(seasons_t)) ## (&#39;春&#39;, &#39;夏&#39;, &#39;秋&#39;, &#39;冬&#39;) 4 hetero_t = (1, 3.14, True, &quot;Hi&quot;) # 建構一個內含整數、浮點、布林、字串的元組，命名為hetero_t。 print(hetero_t) ## (1, 3.14, True, &#39;Hi&#39;) 5.1.2 元組索引 5.1.2.1 零基索引（zero-based indexing） 元組既然是一種彙集，裡頭當然可能裝了一個以上的物件（稱作該彙集中的元素（element）或成員（member）），如果只想對其中某些特定的元素來操作的話，就要指定是哪個，也就是對其索引，而python中的索引是從0開始算的（以零為基礎），也就是說如果有10個元素照順序放在一起，第一個用0來索引、第二個用1來索引、第三個用2來索引，依此類推到第10個則用9來索引。索引方式：「彙集[索引值]」，超出範圍的索引會得到錯誤訊息。具體做法如下： ten_t = (&#39;一&#39;, &#39;二&#39;, &#39;三&#39;, &#39;四&#39;, &#39;五&#39;, &#39;六&#39;, &#39;七&#39;, &#39;八&#39;, &#39;九&#39;, &#39;十&#39;) # 將內有十個字符的元組命名為ten_t。 print(ten_t[0], ten_t[1], ten_t[2], ten_t[4], ten_t[7], ten_t[8]) # 列出排在第1, 2, 3, 5, 8, 9位置的元素。 ## 一 二 三 五 八 九 print(ten_t[10]) # 列出排在第11位置的元素，超出正確索引範圍，發生錯誤。 ## Error in py_call_impl(callable, dots$args, dots$keywords): IndexError: tuple index out of range ## ## Detailed traceback: ## File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt; 5.1.2.2 負值索引 如果有個彙集裝了太多元素，例如超過100個，從頭往尾慢慢數要很久耶，如果我要知道最後一個元素的內容怎麼辦？至少可以有二種作法： 利用函式len( )找出長度，將該長度-1（因為從0起算）再行索引。 直接採用負值索引。 以下我們要找到一個長的元組中，倒數第1, 2, 5個位置上的元素： pi_t = (3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9, 7, 9, 3, 2, 3, 8, 4, 6, 2, 6, 4, 3, 3, 8, 3, 2, 7, 9, 5, 0, 2, 8, 8, 4, 1, 9, 7, 1, 6, 9, 3, 9, 9, 3, 7, 5, 1, 0, 5, 8, 2, 0, 9, 7, 4, 9, 4, 4, 5, 9, 2, 3, 0, 7, 8, 1, 6, 4, 0, 6, 2, 8, 6, 2, 0, 8, 9, 9, 8, 6, 2, 8, 0, 3, 4, 8, 2, 5, 3, 4, 2, 1, 1, 7, 0, 6, 7, 9, 8, 2, 1, 4, 8, 0, 8, 6, 5, 1, 3, 2, 8, 2, 3, 0, 6, 6, 4, 7, 0, 9, 3, 8, 4, 4, 6, 0, 9, 5, 5, 0, 5, 8, 2, 2, 3, 1, 7, 2, 5, 3, 5, 9, 4, 0, 8, 1, 2, 8, 4, 8, 1, 1, 1, 7, 4, 5, 0, 2, 8, 4, 1, 0, 2, 7, 0, 1, 9, 3, 8, 5, 2, 1, 1, 0, 5, 5, 5, 9, 6, 4, 4, 6, 2, 2, 9, 4, 8, 9, 5, 4, 9, 3, 0, 3, 8, 1, 9, 6, 4, 4, 2, 8, 8, 1, 0, 9, 7, 5, 6, 6, 5, 9, 3, 3, 4, 4, 6, 1, 2, 8, 4, 7, 5, 6, 4, 8, 2, 3, 3, 7, 8, 6, 7, 8, 3, 1, 6, 5, 2, 7, 1, 2, 0, 1, 9, 0, 9, 1, 4, 5, 6, 4, 8, 5, 6, 6, 9, 2, 3, 4, 6, 0, 3, 4, 8, 6, 1, 0, 4, 5, 4, 3, 2, 6, 6, 4, 8, 2, 1, 3, 3, 9, 3, 6, 0, 7, 2, 6, 0, 2, 4, 9, 1, 4, 1, 2, 7, 3, 7, 2, 4, 5, 8, 7, 0, 0, 6, 6, 0, 6, 3, 1, 5, 5, 8, 8, 1, 7, 4, 8, 8, 1, 5, 2, 0, 9, 2, 0, 9, 6, 2, 8, 2, 9, 2, 5, 4, 0, 9, 1, 7, 1, 5, 3, 6, 4, 3, 6, 7, 8, 9, 2, 5, 9, 0, 3, 6, 0, 0, 1, 1, 3, 3, 0, 5, 3, 0, 5, 4, 8, 8, 2, 0, 4, 6, 6, 5, 2, 1, 3, 8, 4, 1, 4, 6, 9, 5, 1, 9, 4, 1, 5, 1, 1, 6, 0, 9, 4, 3, 3, 0, 5, 7, 2, 7, 0, 3, 6, 5, 7, 5, 9, 5, 9, 1, 9, 5, 3, 0, 9, 2, 1, 8, 6, 1, 1, 7, 3, 8, 1, 9, 3, 2, 6, 1, 1, 7, 9, 3, 1, 0, 5, 1, 1, 8, 5, 4, 8, 0, 7, 4, 4, 6, 2, 3, 7, 9, 9, 6, 2, 7, 4, 9, 5, 6, 7, 3, 5, 1, 8, 8, 5, 7, 5, 2, 7, 2, 4, 8, 9, 1, 2, 2, 7, 9, 3, 8, 1, 8, 3, 0, 1, 1, 9, 4, 9, 1, 2) print(pi_t[len(pi_t)-1], pi_t[len(pi_t)-2], pi_t[len(pi_t)-5]) ## 2 1 9 print(pi_t[-1], pi_t[-2], pi_t[-5]) ## 2 1 9 看來負值索引的方法更簡潔。 5.1.2.3 範圍索引 範圍索引用在一次找出好幾個不同位置上的元素，方式為「彙集[起點位置:（不含）終點位置]」，索引值可以是負值，實例如下： print(ten_t) # 變項ten_t是有十個字符的元組。 ## (&#39;一&#39;, &#39;二&#39;, &#39;三&#39;, &#39;四&#39;, &#39;五&#39;, &#39;六&#39;, &#39;七&#39;, &#39;八&#39;, &#39;九&#39;, &#39;十&#39;) print(ten_t[2:5]) # 索引2（第3個）～不含索引5（第6個） ## (&#39;三&#39;, &#39;四&#39;, &#39;五&#39;) print(ten_t[5:-2]) # 索引5（第6個）～不含倒數第2個 ## (&#39;六&#39;, &#39;七&#39;, &#39;八&#39;) print(ten_t[-8:7]) # 倒數第8個～不含索引7（第8個） ## (&#39;三&#39;, &#39;四&#39;, &#39;五&#39;, &#39;六&#39;, &#39;七&#39;) 範圍索引如省略起點位置或終點位置的話，各自表示「從頭開始、直到最尾」的意思： print(ten_t[:5]) # 從第一個～不含索引5（第6個） ## (&#39;一&#39;, &#39;二&#39;, &#39;三&#39;, &#39;四&#39;, &#39;五&#39;) print(ten_t[5:]) # 從索引5（第6個）～到最後一個 ## (&#39;六&#39;, &#39;七&#39;, &#39;八&#39;, &#39;九&#39;, &#39;十&#39;) print(ten_t[:]) # 從第一個～到最後一個 ## (&#39;一&#39;, &#39;二&#39;, &#39;三&#39;, &#39;四&#39;, &#39;五&#39;, &#39;六&#39;, &#39;七&#39;, &#39;八&#39;, &#39;九&#39;, &#39;十&#39;) 範圍索引不一定要在位置上連續，也可以有間隔，方式為「彙集[起點位置:（不含）終點位置:間隔]」，如下： print(ten_t[2:8:2]) # 索引2（第3個）～不含索引8（第9個），間隔為2。 ## (&#39;三&#39;, &#39;五&#39;, &#39;七&#39;) print(ten_t[::3]) # 從頭至尾，間隔為3。 ## (&#39;一&#39;, &#39;四&#39;, &#39;七&#39;, &#39;十&#39;) 5.1.3 元組算術運算 前面提及字串可以使用算術運算子的「加」（接續）和「乘」（重複），元組也可以，而且也是先乗再加： print(seasons_t + hetero_t * 2) ## (&#39;春&#39;, &#39;夏&#39;, &#39;秋&#39;, &#39;冬&#39;, 1, 3.14, True, &#39;Hi&#39;, 1, 3.14, True, &#39;Hi&#39;) print(ten_t[1:4] + seasons_t[::2] * 2 + hetero_t[-2:] * 3) ## (&#39;二&#39;, &#39;三&#39;, &#39;四&#39;, &#39;春&#39;, &#39;秋&#39;, &#39;春&#39;, &#39;秋&#39;, True, &#39;Hi&#39;, True, &#39;Hi&#39;, True, &#39;Hi&#39;) 5.1.4 元組常用函式 print(len(seasons_t), len(hetero_t)) # 型別相同或不同，都能回報長度。 ## 4 4 print(max(seasons_t), min(seasons_t)) # 型別相同還能比大小。 ## 秋 冬 print(max(hetero_t), min(hetero_t)) # 型別不同則無大小之分，錯誤。 ## Error in py_call_impl(callable, dots$args, dots$keywords): TypeError: &#39;&gt;&#39; not supported between instances of &#39;str&#39; and &#39;float&#39; ## ## Detailed traceback: ## File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt; print(*zip(seasons_t, hetero_t)) # 將長度相同的彙集中索引位置相同者，弄成同組，再用前置星號展開。 ## (&#39;春&#39;, 1) (&#39;夏&#39;, 3.14) (&#39;秋&#39;, True) (&#39;冬&#39;, &#39;Hi&#39;) print(*enumerate(ten_t)) # 將索引位置與對應的元素，弄成同組，再用前置星號展開。 ## (0, &#39;一&#39;) (1, &#39;二&#39;) (2, &#39;三&#39;) (3, &#39;四&#39;) (4, &#39;五&#39;) (5, &#39;六&#39;) (6, &#39;七&#39;) (7, &#39;八&#39;) (8, &#39;九&#39;) (9, &#39;十&#39;) print(*reversed(ten_t)) # 將元組內的元素反向排列，最前的變成最後的、最後的變成最前的。 ## 十 九 八 七 六 五 四 三 二 一 print(sum(pi_t)) # 將元組內的每個元素相加，求取其和。 ## 2214 5.1.5 元組常用方法 print(pi_t.count(3)) # 回報元組pi_t中有幾個元素的值是3。 ## 51 print(pi_t.index(9)) # 回報元組pi_t中原素為9最早出現在哪個索引值。 ## 5 5.1.6 自我練習（元組） 打開Jupyter或Spyder。 自己建構一些元組，將學過的每個元組可用的函式和方法，至少用自己的例子執行三次，看看與自己的預期是否相同。 5.2 串列（list） 5.2.1 串列建構 前面提到元組可直接用( )小括弧來建構，這裡要學的串列則可直接用[ ]中括弧來建構。 使用函式list( )建構串列當然也沒問題，還可轉換型別。 empty_l = [ ] # 用中括弧來建立元組，這是一個空的串列，命名為empty_list，類別為list，因為裡面沒有東西，所以長度為0。 print(type(empty_l), len(empty_l)) ## &lt;class &#39;list&#39;&gt; 0 seasons_l = list(seasons_t) # 用list( )將元組型別中的各元素放到串列之中。 print(seasons_l, type(seasons_l)) ## [&#39;春&#39;, &#39;夏&#39;, &#39;秋&#39;, &#39;冬&#39;] &lt;class &#39;list&#39;&gt; hetero_l = list(hetero_t) # 用list( )將元組型別中個各元素放到串列之中。 print(hetero_l, type(hetero_l)) ## [1, 3.14, True, &#39;Hi&#39;] &lt;class &#39;list&#39;&gt; print([seasons_t], [hetero_t]) # 只用中括弧的話，則會變成只有一個元素的串列，該元素在此例是個元組。 ## [(&#39;春&#39;, &#39;夏&#39;, &#39;秋&#39;, &#39;冬&#39;)] [(1, 3.14, True, &#39;Hi&#39;)] 5.2.2 串列索引 前面提到元組的各種索引方式，串列全部都可以用。 ten_l = list(ten_t) # 用list( )將元組型別中的各元素放到串列之中。 print(ten_l) # 變項ten_l是有十個字符的串列。 ## [&#39;一&#39;, &#39;二&#39;, &#39;三&#39;, &#39;四&#39;, &#39;五&#39;, &#39;六&#39;, &#39;七&#39;, &#39;八&#39;, &#39;九&#39;, &#39;十&#39;] print(ten_l[2:5]) # 索引2（第3個）～不含索引5（第6個） ## [&#39;三&#39;, &#39;四&#39;, &#39;五&#39;] print(ten_l[5:-2]) # 索引5（第6個）～不含倒數第2個 ## [&#39;六&#39;, &#39;七&#39;, &#39;八&#39;] print(ten_l[-8:7]) # 倒數第8個～不含索引7（第8個） ## [&#39;三&#39;, &#39;四&#39;, &#39;五&#39;, &#39;六&#39;, &#39;七&#39;] print(ten_l[:5]) # 從第一個～不含索引5（第6個） ## [&#39;一&#39;, &#39;二&#39;, &#39;三&#39;, &#39;四&#39;, &#39;五&#39;] print(ten_l[5:]) # 從索引5（第6個）～到最後一個 ## [&#39;六&#39;, &#39;七&#39;, &#39;八&#39;, &#39;九&#39;, &#39;十&#39;] print(ten_l[:]) # 從第一個～到最後一個 ## [&#39;一&#39;, &#39;二&#39;, &#39;三&#39;, &#39;四&#39;, &#39;五&#39;, &#39;六&#39;, &#39;七&#39;, &#39;八&#39;, &#39;九&#39;, &#39;十&#39;] print(ten_l[2:8:2]) # 索引2（第3個）～不含索引8（第9個），間隔為2。 ## [&#39;三&#39;, &#39;五&#39;, &#39;七&#39;] print(ten_l[::3]) # 從頭至尾，間隔為3。 ## [&#39;一&#39;, &#39;四&#39;, &#39;七&#39;, &#39;十&#39;] 5.2.3 串列算術運算、常用函式、常用方法 前面提及元組可以使用的算術運算、函式、方法，全部可以用在串列上： print(seasons_l + hetero_l * 2) # 先乘後加。 ## [&#39;春&#39;, &#39;夏&#39;, &#39;秋&#39;, &#39;冬&#39;, 1, 3.14, True, &#39;Hi&#39;, 1, 3.14, True, &#39;Hi&#39;] print(ten_l[1:4] + seasons_l[::2] * 2 + hetero_l[-2:] * 3) # 混合索引與先乘後加的運算。 ## [&#39;二&#39;, &#39;三&#39;, &#39;四&#39;, &#39;春&#39;, &#39;秋&#39;, &#39;春&#39;, &#39;秋&#39;, True, &#39;Hi&#39;, True, &#39;Hi&#39;, True, &#39;Hi&#39;] print(len(seasons_l), len(hetero_l)) # 型別相同或不同，都能回報長度。 ## 4 4 print(max(seasons_l), min(seasons_l)) # 型別相同還能比大小。 ## 秋 冬 print(max(hetero_l), min(hetero_l)) # 型別不同則無大小之分，錯誤。 ## Error in py_call_impl(callable, dots$args, dots$keywords): TypeError: &#39;&gt;&#39; not supported between instances of &#39;str&#39; and &#39;float&#39; ## ## Detailed traceback: ## File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt; print(*zip(seasons_l, hetero_l)) # 將長度相同的彙集中索引位置相同者，弄成同組，再用前置星號展開。 ## (&#39;春&#39;, 1) (&#39;夏&#39;, 3.14) (&#39;秋&#39;, True) (&#39;冬&#39;, &#39;Hi&#39;) print(*enumerate(ten_l)) # 將索引位置與對應的元素，弄成同組，再用前置星號展開。 ## (0, &#39;一&#39;) (1, &#39;二&#39;) (2, &#39;三&#39;) (3, &#39;四&#39;) (4, &#39;五&#39;) (5, &#39;六&#39;) (6, &#39;七&#39;) (7, &#39;八&#39;) (8, &#39;九&#39;) (9, &#39;十&#39;) print(*reversed(ten_l)) # 將元組內的元素反向排列，最前的變成最後的、最後的變成最前的。 ## 十 九 八 七 六 五 四 三 二 一 pi_l = list(pi_t) # 用list( )將元組型別中的各元素放到串列之中。 print(sum(pi_l)) # 將串列內的每個元素相加，求取其和。 ## 2214 print(pi_l.count(3)) # 回報串列pi_l中有幾個元素的值是3。 ## 51 print(pi_l.index(9)) # 回報串列pi_l中原素為9最早出現在哪個索引值。 ## 5 5.2.4 物件可變與否 學到這裡，也許你有疑問：元組有的功能串列都有，那為什麼python要區分這二者呢？事實上串列比元組多出很多功能，因為串列是「可變的（mutable）」而元組是「不可變的（immutable）」，前面學過的整數、符點、布林、字串也都是不可變的。我們用例子來學： print(ten_t, &quot;\\n&quot;, ten_l) # 列出元組ten_t和串列ten_l，其中&quot;\\n&quot;是「到下一排」的意思。 ## (&#39;一&#39;, &#39;二&#39;, &#39;三&#39;, &#39;四&#39;, &#39;五&#39;, &#39;六&#39;, &#39;七&#39;, &#39;八&#39;, &#39;九&#39;, &#39;十&#39;) ## [&#39;一&#39;, &#39;二&#39;, &#39;三&#39;, &#39;四&#39;, &#39;五&#39;, &#39;六&#39;, &#39;七&#39;, &#39;八&#39;, &#39;九&#39;, &#39;十&#39;] ten_t[0] = &quot;零&quot; # 對元組索引0的第一個元素，用&quot;零&quot;取代，發生錯誤，元組為不可變的，不能改變其中元素。 ## Error in py_call_impl(callable, dots$args, dots$keywords): TypeError: &#39;tuple&#39; object does not support item assignment ## ## Detailed traceback: ## File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt; ten_l[0] = &quot;零&quot; # 對串列索引0的第一個元素，用&quot;零&quot;取代，沒有錯誤，串列為可變的，能夠改變其中元素。 print(ten_l) ## [&#39;零&#39;, &#39;二&#39;, &#39;三&#39;, &#39;四&#39;, &#39;五&#39;, &#39;六&#39;, &#39;七&#39;, &#39;八&#39;, &#39;九&#39;, &#39;十&#39;] ppap = &quot;PenPineappleApplePen&quot; # 建構一個字串。 print(ppap[7]) # 列出字串ppap索引7的第八個元素。 ## a ppap[7] = &quot;A&quot; # 對字串索引7的第八個元素，用&quot;A&quot;取代，發生錯誤，字串為不可變的，不能改變其中元素。 ## Error in py_call_impl(callable, dots$args, dots$keywords): TypeError: &#39;str&#39; object does not support item assignment ## ## Detailed traceback: ## File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt; 5.2.5 串列可用方法 因為串列是可變的，它內含元素可以變動，所以比元組有很多方法可用，以下這些方法不能用在元組上： print(ten_l) # 列出ten_t串列。 ## [&#39;零&#39;, &#39;二&#39;, &#39;三&#39;, &#39;四&#39;, &#39;五&#39;, &#39;六&#39;, &#39;七&#39;, &#39;八&#39;, &#39;九&#39;, &#39;十&#39;] ten_l.append(&quot;十一&quot;) # 增加一個元素。 print(ten_l) ## [&#39;零&#39;, &#39;二&#39;, &#39;三&#39;, &#39;四&#39;, &#39;五&#39;, &#39;六&#39;, &#39;七&#39;, &#39;八&#39;, &#39;九&#39;, &#39;十&#39;, &#39;十一&#39;] ten_l.extend([&quot;十二&quot;, &quot;十三&quot;]) # 增加一個串列。 print(ten_l) ## [&#39;零&#39;, &#39;二&#39;, &#39;三&#39;, &#39;四&#39;, &#39;五&#39;, &#39;六&#39;, &#39;七&#39;, &#39;八&#39;, &#39;九&#39;, &#39;十&#39;, &#39;十一&#39;, &#39;十二&#39;, &#39;十三&#39;] ten_l.insert(3, 2.5) # 在指定的索引位置插入一個元素。 print(ten_l) ## [&#39;零&#39;, &#39;二&#39;, &#39;三&#39;, 2.5, &#39;四&#39;, &#39;五&#39;, &#39;六&#39;, &#39;七&#39;, &#39;八&#39;, &#39;九&#39;, &#39;十&#39;, &#39;十一&#39;, &#39;十二&#39;, &#39;十三&#39;] ten_l.pop(3) # 移除特定索引位置的元素。 ## 2.5 print(ten_l) ## [&#39;零&#39;, &#39;二&#39;, &#39;三&#39;, &#39;四&#39;, &#39;五&#39;, &#39;六&#39;, &#39;七&#39;, &#39;八&#39;, &#39;九&#39;, &#39;十&#39;, &#39;十一&#39;, &#39;十二&#39;, &#39;十三&#39;] ten_l_2 = ten_l # 讓二個變項指涉相同內容。 ten_l_2[10] = 11 # 更改新變項的某個元素。 print(ten_l_2) # 檢查新變項內容是否改變。 ## [&#39;零&#39;, &#39;二&#39;, &#39;三&#39;, &#39;四&#39;, &#39;五&#39;, &#39;六&#39;, &#39;七&#39;, &#39;八&#39;, &#39;九&#39;, &#39;十&#39;, 11, &#39;十二&#39;, &#39;十三&#39;] print(ten_l) # 檢查原來變項內容是否改變。 ## [&#39;零&#39;, &#39;二&#39;, &#39;三&#39;, &#39;四&#39;, &#39;五&#39;, &#39;六&#39;, &#39;七&#39;, &#39;八&#39;, &#39;九&#39;, &#39;十&#39;, 11, &#39;十二&#39;, &#39;十三&#39;] ten_l_copy = ten_l.copy() # 淺的複製一個串列，先不必管什麼是「淺的」。 print(ten_l_copy == ten_l, id(ten_l_copy), id(ten_l)) # 測試兩者是否相等，是否為同一物件。 ## True 660435912 662841736 ten_l_copy[11] = 12 # 更改複製變項的某個元素。 print(ten_l_copy) # 檢查複製變項內容是否改變。 ## [&#39;零&#39;, &#39;二&#39;, &#39;三&#39;, &#39;四&#39;, &#39;五&#39;, &#39;六&#39;, &#39;七&#39;, &#39;八&#39;, &#39;九&#39;, &#39;十&#39;, 11, 12, &#39;十三&#39;] print(ten_l) # 檢查原來變項內容是否改變。 ## [&#39;零&#39;, &#39;二&#39;, &#39;三&#39;, &#39;四&#39;, &#39;五&#39;, &#39;六&#39;, &#39;七&#39;, &#39;八&#39;, &#39;九&#39;, &#39;十&#39;, 11, &#39;十二&#39;, &#39;十三&#39;] 既然可變的串列list的功能比不可變的元組tuple多，那麼為何還要保留元組的存在呢？全都用串列就好啦！ 事實上，很多常見的地方還是用元組方便的，比如說我們之前學過的交換「a, b = b, a」其實就是把指派運算子右側的b, a二個元素先弄成元組，在左側再將元組解開成二個元素讓a, b變項指涉原來b, a所指涉的內容。 a, b = 1, 2 c1 = a, b print(c1, type(c1)) ## (1, 2) &lt;class &#39;tuple&#39;&gt; b, a = a, b c2 = a, b print(c2, type(c2)) ## (2, 1) &lt;class &#39;tuple&#39;&gt; 5.2.6 學習要點（可索引的物件） 字串、元組、串列都是可被索引的，可以索引的物件就有特定的順序關係（元素有固定的位置），因此都是有序的，但其中只有串列是可變的： 型別 名稱 有序與否 可變與否 string 字串 是 否 tuple 元組 是 否 list 串列 是 是 5.2.7 自我練習（串列） 打開Jupyter或Spyder。 自己建構一些串列，將學過的每個串列可用的函式和方法，至少用自己的例子執行三次，看看與自己的預期是否相同。 5.3 集合（set） 5.3.1 集合建構 集合是由無序的不重複的元素所構成的彙集，一定要用set( )來建構，而不能直接用大括弧{ }，因為後者已經被後面會提到的字典用掉了。 empty_d = {} # 只用大括弧，會變成字典（dictionary）。 empty_s = set( ) # 建構一個空集合。 print(type(empty_d), type(empty_s)) # 列出型別。 ## &lt;class &#39;dict&#39;&gt; &lt;class &#39;set&#39;&gt; ten_s = set(ten_t) # 用set( )將元組型別中的各元素放到集合之中。 print(ten_s) # 請注意，列出結果順序與原來的元組不同，因為集合中的元素是沒有順序概念的。 ## {&#39;六&#39;, &#39;九&#39;, &#39;五&#39;, &#39;四&#39;, &#39;二&#39;, &#39;三&#39;, &#39;一&#39;, &#39;十&#39;, &#39;八&#39;, &#39;七&#39;} print(ten_s[0]) # 因為沒有順序的概念，無法用位置來索引到特定元素，所以發生錯誤。 ## Error in py_call_impl(callable, dots$args, dots$keywords): TypeError: &#39;set&#39; object is not subscriptable ## ## Detailed traceback: ## File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt; pi_s = set(pi_t) # 用set( )將元組型別中的各元素放到集合之中，重複元素會被移除。 print(pi_s) ## {0, 1, 2, 3, 4, 5, 6, 7, 8, 9} 5.3.2 集合方法 集合雖然沒有順序，但它是可變的，我們可以增減刪改其中元素，所以集合也有很多方法可用： tiengan_s = set([&quot;甲&quot;, &quot;乙&quot;, &quot;丙&quot;, &quot;丁&quot;, &quot;戊&quot;]) # 建構一個含有五個元素的集合。 print(tiengan_s) ## {&#39;戊&#39;, &#39;丙&#39;, &#39;丁&#39;, &#39;乙&#39;, &#39;甲&#39;} tiengan_s.add(&quot;己&quot;) # 添加一個元素。 print(tiengan_s) ## {&#39;戊&#39;, &#39;丙&#39;, &#39;己&#39;, &#39;丁&#39;, &#39;乙&#39;, &#39;甲&#39;} tiengan_s.update([&quot;戊&quot;, &quot;己&quot;, &quot;庚&quot;, &quot;辛&quot;]) # 用串列中的四個元素更新集合內容，元素不會重複。 print(tiengan_s) ## {&#39;庚&#39;, &#39;辛&#39;, &#39;戊&#39;, &#39;丙&#39;, &#39;己&#39;, &#39;丁&#39;, &#39;乙&#39;, &#39;甲&#39;} tiengan_s.remove(&quot;丙&quot;) # 用remove移除一個元素。 print(tiengan_s) ## {&#39;庚&#39;, &#39;辛&#39;, &#39;戊&#39;, &#39;己&#39;, &#39;丁&#39;, &#39;乙&#39;, &#39;甲&#39;} tiengan_s.remove(&quot;丙&quot;) # 用remove移除不存在的元素，會發生錯誤。 ## Error in py_call_impl(callable, dots$args, dots$keywords): KeyError: &#39;銝㤼㸹&#39; ## ## Detailed traceback: ## File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt; tiengan_s.discard(&quot;丁&quot;) # 用discard移除另一個元素。 print(tiengan_s) ## {&#39;庚&#39;, &#39;辛&#39;, &#39;戊&#39;, &#39;己&#39;, &#39;乙&#39;, &#39;甲&#39;} tiengan_s.discard(&quot;丁&quot;) # 用discard移除不存在的元素，不會發生錯誤。 tiengan_s.pop() # 用pop移除任一元素，因為集合是無序的，所以不確定結果是哪個元素被移除。 ## &#39;庚&#39; print(tiengan_s) ## {&#39;辛&#39;, &#39;戊&#39;, &#39;己&#39;, &#39;乙&#39;, &#39;甲&#39;} 以下我們來看一下基本的集合運算，包括測試是否為子集或超集，找出二個集合之間的交集、聯集、差集等： # 先從前面的元組建構一些集合備用，列出它們的內容。 set_t = set(ten_t) set_a = set(ten_t[1:6]) set_b = set(ten_t[3:8]) print(set_t, &quot;\\n&quot;, set_a, set_b) ## {&#39;六&#39;, &#39;九&#39;, &#39;五&#39;, &#39;四&#39;, &#39;二&#39;, &#39;三&#39;, &#39;一&#39;, &#39;十&#39;, &#39;八&#39;, &#39;七&#39;} ## {&#39;六&#39;, &#39;五&#39;, &#39;四&#39;, &#39;二&#39;, &#39;三&#39;} {&#39;六&#39;, &#39;五&#39;, &#39;四&#39;, &#39;八&#39;, &#39;七&#39;} print(set_a.issubset(set_t), set_t.issubset(set_b)) # 測試是否為子集。 ## True False print(set_a.issuperset(set_t), set_t.issuperset(set_b)) # 測試是否為超集。 ## False True print(set_a.intersection(set_b)) # 交集，在set_a且在set_b。 ## {&#39;六&#39;, &#39;四&#39;, &#39;五&#39;} print(set_a.difference(set_b)) # 差集，在set_a，不在set_b。 ## {&#39;二&#39;, &#39;三&#39;} print(set_b.difference(set_a)) # 差集，在set_b，不在set_a。 ## {&#39;八&#39;, &#39;七&#39;} print(set_a.union(set_b)) # 聯集，在set_a或在set_b。 ## {&#39;六&#39;, &#39;五&#39;, &#39;二&#39;, &#39;四&#39;, &#39;三&#39;, &#39;八&#39;, &#39;七&#39;} set_t.clear() # 移除集合中所有元素。 print(set_t) # 沒有元素的集合即為空集合。 ## set() 5.3.3 自我練習（集合） 打開Jupyter或Spyder。 自己建構一些集合，將學過的每個集合可用的函式和方法，至少用自己的例子執行三次，看看與自己的預期是否相同。 5.4 字典（dictionary） 5.4.1 字典建構 字典可以用dict( )函式來建構，也可以用前面提過的大括弧{ }來建構，如果是後者，寫法是這樣的：「{鍵1:值1, 鍵2:值2, 鍵3:值3, …}」，例示如下： fruits_d = {&#39;A&#39;: &#39;Apple&#39;, &#39;B&#39;: &#39;Banana&#39;, &#39;C&#39;: &#39;Cherry&#39;} print(fruits_d, type(fruits_d)) ## {&#39;A&#39;: &#39;Apple&#39;, &#39;B&#39;: &#39;Banana&#39;, &#39;C&#39;: &#39;Cherry&#39;} &lt;class &#39;dict&#39;&gt; 5.4.2 字典索引 字典與集合相同的是它也是無序的，其中的元素沒有固定位置的概念，與串列和元素相同的是，字典也是可變的，因為我們可以對字典增刪修改內容。 字典中元素沒有固定位置，所以不能用位置來索引，但因為其中的「鍵（key）」是不可變而且是不重覆的，所以我們可以用它來索引，並且用來增刪內容。 fruits_d[&#39;A&#39;] # 回報特定鍵所對應的值。 ## &#39;Apple&#39; fruits_d[&#39;C&#39;] = &#39;Cantaloupe&#39; # 修改特定鍵所對應的值。 fruits_d[&#39;D&#39;] = &#39;Dewberries&#39; # 如果索引用的鍵並不在字典中，則此指派將會新增一對鍵與值。 print(fruits_d) ## {&#39;A&#39;: &#39;Apple&#39;, &#39;B&#39;: &#39;Banana&#39;, &#39;C&#39;: &#39;Cantaloupe&#39;, &#39;D&#39;: &#39;Dewberries&#39;} fruits_d[(&#39;E&#39;, &#39;F&#39;)] = (&#39;Eggfruit&#39;, &#39;Fig&#39;) # 元組為不可變的，可以作為鍵來使用。 print(fruits_d) ## {&#39;A&#39;: &#39;Apple&#39;, &#39;B&#39;: &#39;Banana&#39;, &#39;C&#39;: &#39;Cantaloupe&#39;, &#39;D&#39;: &#39;Dewberries&#39;, (&#39;E&#39;, &#39;F&#39;): (&#39;Eggfruit&#39;, &#39;Fig&#39;)} fruits_d[[&#39;G&#39;, &#39;H&#39;]] = [&#39;Grape&#39;, &#39;Honeydew&#39;] # 串列是可變的，作為鍵會產生錯誤。 ## Error in py_call_impl(callable, dots$args, dots$keywords): TypeError: unhashable type: &#39;list&#39; ## ## Detailed traceback: ## File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt; 5.4.3 字典方法 幾個字典常用方法如下： fruits_d.items() # 回報每對鍵與值。 ## dict_items([(&#39;A&#39;, &#39;Apple&#39;), (&#39;B&#39;, &#39;Banana&#39;), (&#39;C&#39;, &#39;Cantaloupe&#39;), (&#39;D&#39;, &#39;Dewberries&#39;), ((&#39;E&#39;, &#39;F&#39;), (&#39;Eggfruit&#39;, &#39;Fig&#39;))]) fruits_d.keys() # 回報全部的鍵，鍵不能重覆。 ## dict_keys([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, (&#39;E&#39;, &#39;F&#39;)]) fruits_d.values() # 回報全部的值，值可以重覆。 ## dict_values([&#39;Apple&#39;, &#39;Banana&#39;, &#39;Cantaloupe&#39;, &#39;Dewberries&#39;, (&#39;Eggfruit&#39;, &#39;Fig&#39;)]) fruits_d.get(&#39;B&#39;) # 回報特定鍵所對應的值。 ## &#39;Banana&#39; fruits_d.pop(&#39;D&#39;) # 移除一對鍵與值。 ## &#39;Dewberries&#39; print(fruits_d) ## {&#39;A&#39;: &#39;Apple&#39;, &#39;B&#39;: &#39;Banana&#39;, &#39;C&#39;: &#39;Cantaloupe&#39;, (&#39;E&#39;, &#39;F&#39;): (&#39;Eggfruit&#39;, &#39;Fig&#39;)} 5.4.4 學習要點（型別、索引、有序、可變） 學習到現在，有幾個型別包括字串、元組、串列、集合、字典等，它們的特性及操作方式，應該都已經有概念了，現在再將它們是否能被索引、元素是否有序、內容是否可變，表列如下， 型別 名稱 索引 有序與否 可變與否 string 字串 位置 是 否 tuple 元組 位置 是 否 list 串列 位置 是 是 set 集合 無 否 是 dictionary 字典 鍵 否 是 5.4.5 自我練習（字典） 打開Jupyter或Spyder。 自己建構一些字典，將學過的每個字典可用的函式和方法，至少用自己的例子執行三次，看看與自己的預期是否相同。 5.5 巢式彙集（nested collection） 5.5.1 巢式彙集建構 從上面字典的例子，可以看到含有多個元素的元組，可以作為字典的鍵與值，事實上只要不違反這些彙集的建構規則，彙集之中的元素可以是另一個彙集，因為結構會變得比較複雜，這裡先不深入去談，只要瞭解它們可以一個套一個，最後有可能形成多層次的複雜構造。 5.5.2 自我練習（巢式彙集） 打開Jupyter或Spyder。 自己建構一些巢式彙集，隨意使用前面學過的各種函式或方法來操作，看看自己有沒有辦法從多層次的結構一路索引到最深的元素，如果它是可變的，則嘗試修改它。 "],
["序列型別sequence-types.html", "6 序列型別（Sequence Types） 6.1 範圍（range） 6.2 字串（string, sequence） 6.3 查找變項型別及其方法 6.4 學習要點（序列型別） 6.5 自我練習（序列型別）", " 6 序列型別（Sequence Types） 前面提到「字串（string）、元組（tuple）、串列（list）」等都是有序的，也就是說其中元素的排列有其順序，這些有內在順序的型別，稱為序列型別（sequence types）。 這裡再新學一個range( )函式，它會回報一個「範圍物件」，該物件同樣也是一種序列。 還有，因為字串是很基本的型別，它的列出格式其實可以有很多變化，還有其他與串列相關的方法，如：拆分（split）、結合（join），本章我們就這方面來看一些應用。 至此我們已經學了不少型別，每種型別都有與其他型別相同或不相同的方法，要怎樣能夠很快地知道某個型別的物件有哪些方法可用呢？如果在使用時用了很多不同的變項名稱來指涉物件，快弄不清楚有哪些變項，每個變項名稱代表什麼型別的物件？怎麼辦呢？請接著看本章後面解決方法。 接著我們對序列型別的共用方法再回顧複習一下。 6.1 範圍（range） 6.1.1 範圍建構 在「基本彙集型別」那一章，我們學過了「範圍索引」，範圍物件也是同樣概念，它是一連串的整數，預設也是以零作為起點，直到最接近終點但不是終點的那個整數。我們一樣用例子來學習： # 只輸入一個值，代表終點的值，如果輸入0為終點，起點預設也是0，因為沒有「從0開始到小於0的最大整數」，長度為0。 r0 = range(0) r1 = range(1) r2 = range(2) r3 = range(3) print(type(r0), len(r0), r0, *r0) # 列出型別、長度、物件、展開物件。 ## &lt;class &#39;range&#39;&gt; 0 range(0, 0) print(type(r1), len(r1), r1, *r1) ## &lt;class &#39;range&#39;&gt; 1 range(0, 1) 0 print(type(r2), len(r2), r2, *r2) ## &lt;class &#39;range&#39;&gt; 2 range(0, 2) 0 1 print(type(r2), len(r2), r2, *r2) ## &lt;class &#39;range&#39;&gt; 2 range(0, 2) 0 1 如果輸入二個值，第一個是起點，第二個是終點，實際範圍會小於終點，如下： r23 = range(2, 3) r35 = range(3, 5) r58 = range(5, 8) print(type(r23), len(r23), r23, *r23) ## &lt;class &#39;range&#39;&gt; 1 range(2, 3) 2 print(type(r35), len(r35), r35, *r35) ## &lt;class &#39;range&#39;&gt; 2 range(3, 5) 3 4 print(type(r58), len(r58), r58, *r58) ## &lt;class &#39;range&#39;&gt; 3 range(5, 8) 5 6 7 如果輸入三個值，第三個是間隔，如下： r272 = range(2, 7, 2) r193 = range(1, 9, 3) print(type(r272), len(r272), r272, *r272) ## &lt;class &#39;range&#39;&gt; 3 range(2, 7, 2) 2 4 6 print(type(r193), len(r193), r193, *r193) ## &lt;class &#39;range&#39;&gt; 3 range(1, 9, 3) 1 4 7 6.1.2 範圍用途 範圍（range）在後面談到迴圈（loop）時很好用，我們留待那時再談。 6.2 字串（string, sequence） 6.2.1 字串格式 這裡我們來學字串的格式format( )方法，請看以下例子： name_1 = &quot;黑妞&quot; name_2 = &quot;白爺&quot; age_1 = 2 age_2 = 5 animal_1 = &quot;狗兒&quot; animal_2 = &quot;貓兒&quot; say_1 = &quot;汪嗚&quot; say_2 = &quot;喵凹&quot; string_a = &quot;我的好朋友叫{}，牠今年{}歲，是隻{}，最愛說的話是「{}」！&quot; pet_a1 = string_a.format(name_1, age_1, animal_1, say_1) pet_a2 = string_a.format(name_2, age_2, animal_2, say_2) print(pet_a1, &quot;\\n&quot;, pet_a2) ## 我的好朋友叫黑妞，牠今年2歲，是隻狗兒，最愛說的話是「汪嗚」！ ## 我的好朋友叫白爺，牠今年5歲，是隻貓兒，最愛說的話是「喵凹」！ string_b = &quot;我的好朋友叫{0}，牠今年{1}歲，是隻{2}，最愛說的話是「{3}」！&quot; pet_b1 = string_b.format(name_1, age_1, animal_1, say_1) pet_b2 = string_b.format(name_2, age_2, animal_2, say_2) print(pet_b1, &quot;\\n&quot;, pet_b2) ## 我的好朋友叫黑妞，牠今年2歲，是隻狗兒，最愛說的話是「汪嗚」！ ## 我的好朋友叫白爺，牠今年5歲，是隻貓兒，最愛說的話是「喵凹」！ string_c = &quot;我的好朋友叫{name}，牠今年{age}歲，是隻{animal}，最愛說的話是「{say}」！&quot; pet_c1 = string_c.format(name = name_1, age = age_1, animal = animal_1, say = say_1) pet_c2 = string_c.format(name = name_2, age = age_2, animal = animal_2, say = say_2) print(pet_c1, &quot;\\n&quot;, pet_c2) ## 我的好朋友叫黑妞，牠今年2歲，是隻狗兒，最愛說的話是「汪嗚」！ ## 我的好朋友叫白爺，牠今年5歲，是隻貓兒，最愛說的話是「喵凹」！ 6.2.2 字串輸入 我們可以用input( )函式來取得讓使用者輸入的字串，該函式所用的引數（餵給該函式的東西），一般是提示使用者輸入的話語，舉例如下： name = input(&quot;請輸入您寵物的名字：&quot;) ## Error in py_call_impl(callable, dots$args, dots$keywords): EOFError: EOF when reading a line ## ## Detailed traceback: ## File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt; age = input(&quot;請輸入您寵物的年紀：&quot;) ## Error in py_call_impl(callable, dots$args, dots$keywords): EOFError: EOF when reading a line ## ## Detailed traceback: ## File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt; animal = input(&quot;請輸入您寵物是哪種動物：&quot;) ## Error in py_call_impl(callable, dots$args, dots$keywords): EOFError: EOF when reading a line ## ## Detailed traceback: ## File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt; say = input(&quot;請輸入您寵物的叫聲：&quot;) ## Error in py_call_impl(callable, dots$args, dots$keywords): EOFError: EOF when reading a line ## ## Detailed traceback: ## File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt; print(string_a.format(name, age, animal, say)) ## Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name &#39;name&#39; is not defined ## ## Detailed traceback: ## File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt; 6.2.3 字串的分拆和結合 前面學過的字串方法不包括字串的拆分和結合，我們先學拆分，split( )方法的作用是將整個字串在每個空白或指定字符處切開成串列中的各個元素。 ppap = &quot;Pen Pineapple Apple Pen&quot; ppap_splitted = ppap.split() print(ppap, &quot;\\n&quot;, ppap_splitted) ## Pen Pineapple Apple Pen ## [&#39;Pen&#39;, &#39;Pineapple&#39;, &#39;Apple&#39;, &#39;Pen&#39;] pet_a1_splitted = pet_a1.split(&quot;，&quot;) print(pet_a1_splitted) ## [&#39;我的好朋友叫黑妞&#39;, &#39;牠今年2歲&#39;, &#39;是隻狗兒&#39;, &#39;最愛說的話是「汪嗚」！&#39;] 結合的話則用join( )方法，因為它是一個字串方法而不是串列方法，所以是「間隔字串.join(串列)」而不能反過來操作。 ppap_joined = &quot;~&quot;.join(ppap_splitted) print(ppap_joined) ## Pen~Pineapple~Apple~Pen pet_a1_joined = &quot;！&quot;.join(pet_a1_splitted) print(pet_a1_joined) ## 我的好朋友叫黑妞！牠今年2歲！是隻狗兒！最愛說的話是「汪嗚」！ 6.3 查找變項型別及其方法 變項越弄越多，要知道哪個變項是什麼型別什麼內容，使用spyder可直接觀察右上區塊的「Variable explorer」，直接在該窗頁查找即可，畫面如下： 要看環境中有哪些變項，以及各個變項有哪些方法，可使用dir( )函式： print(dir( )) # 查看環境中的變項。 ## [&#39;R&#39;, &#39;__annotations__&#39;, &#39;__builtins__&#39;, &#39;__doc__&#39;, &#39;__loader__&#39;, &#39;__name__&#39;, &#39;__package__&#39;, &#39;__spec__&#39;, &#39;age_1&#39;, &#39;age_2&#39;, &#39;animal_1&#39;, &#39;animal_2&#39;, &#39;name_1&#39;, &#39;name_2&#39;, &#39;pet_a1&#39;, &#39;pet_a1_joined&#39;, &#39;pet_a1_splitted&#39;, &#39;pet_a2&#39;, &#39;pet_b1&#39;, &#39;pet_b2&#39;, &#39;pet_c1&#39;, &#39;pet_c2&#39;, &#39;ppap&#39;, &#39;ppap_joined&#39;, &#39;ppap_splitted&#39;, &#39;r&#39;, &#39;r0&#39;, &#39;r1&#39;, &#39;r193&#39;, &#39;r2&#39;, &#39;r23&#39;, &#39;r272&#39;, &#39;r3&#39;, &#39;r35&#39;, &#39;r58&#39;, &#39;say_1&#39;, &#39;say_2&#39;, &#39;string_a&#39;, &#39;string_b&#39;, &#39;string_c&#39;, &#39;sys&#39;] print(dir(ppap)) # 查看ppap這個字串變項有哪些方法。 ## [&#39;__add__&#39;, &#39;__class__&#39;, &#39;__contains__&#39;, &#39;__delattr__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__getitem__&#39;, &#39;__getnewargs__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__iter__&#39;, &#39;__le__&#39;, &#39;__len__&#39;, &#39;__lt__&#39;, &#39;__mod__&#39;, &#39;__mul__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__rmod__&#39;, &#39;__rmul__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;capitalize&#39;, &#39;casefold&#39;, &#39;center&#39;, &#39;count&#39;, &#39;encode&#39;, &#39;endswith&#39;, &#39;expandtabs&#39;, &#39;find&#39;, &#39;format&#39;, &#39;format_map&#39;, &#39;index&#39;, &#39;isalnum&#39;, &#39;isalpha&#39;, &#39;isascii&#39;, &#39;isdecimal&#39;, &#39;isdigit&#39;, &#39;isidentifier&#39;, &#39;islower&#39;, &#39;isnumeric&#39;, &#39;isprintable&#39;, &#39;isspace&#39;, &#39;istitle&#39;, &#39;isupper&#39;, &#39;join&#39;, &#39;ljust&#39;, &#39;lower&#39;, &#39;lstrip&#39;, &#39;maketrans&#39;, &#39;partition&#39;, &#39;replace&#39;, &#39;rfind&#39;, &#39;rindex&#39;, &#39;rjust&#39;, &#39;rpartition&#39;, &#39;rsplit&#39;, &#39;rstrip&#39;, &#39;split&#39;, &#39;splitlines&#39;, &#39;startswith&#39;, &#39;strip&#39;, &#39;swapcase&#39;, &#39;title&#39;, &#39;translate&#39;, &#39;upper&#39;, &#39;zfill&#39;] print(dir(ppap_splitted)) # 查看ppap_splitted這個串列變項有哪些方法。 ## [&#39;__add__&#39;, &#39;__class__&#39;, &#39;__contains__&#39;, &#39;__delattr__&#39;, &#39;__delitem__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__getitem__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__iadd__&#39;, &#39;__imul__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__iter__&#39;, &#39;__le__&#39;, &#39;__len__&#39;, &#39;__lt__&#39;, &#39;__mul__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__reversed__&#39;, &#39;__rmul__&#39;, &#39;__setattr__&#39;, &#39;__setitem__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;append&#39;, &#39;clear&#39;, &#39;copy&#39;, &#39;count&#39;, &#39;extend&#39;, &#39;index&#39;, &#39;insert&#39;, &#39;pop&#39;, &#39;remove&#39;, &#39;reverse&#39;, &#39;sort&#39;] 6.4 學習要點（序列型別） 明白如何使用range( )建構範圍物件。 明白如何使用字串的format( )方法來改變格式，並且會用input( )函式來取得使用者的輸入值，能夠運用字串的拆分split( )與結合join( )方法。 知道如何在spyder中查看物件型別及其內容，知道如何找到特定物件可用哪些方法。 假設序列s和序列t是相同型別，n、i、j、k是整數，x是序列可接受的元素，序列可用方法列示如下： 運算 作用 可變序列能用 x&lt;U+00A0&gt;in&lt;U+00A0&gt;s 如元素x在序列s中回報真，否則回報假。 否 x&lt;U+00A0&gt;not&lt;U+00A0&gt;in&lt;U+00A0&gt;s 如元素x不在序列中回報真，否則回報假。 否 s&lt;U+00A0&gt;+&lt;U+00A0&gt;t 將序列s與序列t串接。 否 s&lt;U+00A0&gt;&lt;U+00A0&gt;n&lt;U+00A0&gt;或&lt;U+00A0&gt;n&lt;U+00A0&gt;&lt;U+00A0&gt;s 將序列s串接n次。 否 s[i] 取得序列s索引位置為i的元素。 否 s[i:j] 取得序列s索引位置為i至未達j的元素。 否 s[i:j:k] 取得序列s索引位置為i至未達j且間隔k的元素。 否 len(s) 取得序列s的長度。 否 min(s) 取得序列s中最小的元素。 否 max(s) 取得序列s中最大的元素。 否 s.index(x[,&lt;U+00A0&gt;i[,&lt;U+00A0&gt;j]]) 取得序列s中首次出現元素x的索引位置，自i起算至未達j。 否 s.count(x) 取得序列s中元素x的個數。 否 s[i]&lt;U+00A0&gt;=&lt;U+00A0&gt;x 將序列s索引位置為i的元素用x替代。 是 s[i:j]&lt;U+00A0&gt;=&lt;U+00A0&gt;t 將序列s索引位置為i至未達j的序列用元素t來替代。 是 del&lt;U+00A0&gt;s[i:j] 刪除序列s索引位置為i至未達j的元素，等同 s[i:j]&lt;U+00A0&gt;=&lt;U+00A0&gt;[]。 是 s[i:j:k]&lt;U+00A0&gt;=&lt;U+00A0&gt;t 將序列s索引位置為i至未達j且間隔k的序列用元素t來替代。 是 del&lt;U+00A0&gt;s[i:j:k] 刪除序列s索引位置為i至未達j且間隔k的元素。 是 s.append(x) 將元素x附加到序列s的尾端，等同&lt;U+00A0&gt;s[len(s):len(s)]&lt;U+00A0&gt;=&lt;U+00A0&gt;[x]。 是 s.clear() 刪除序列s中的全部元素，等同&lt;U+00A0&gt;del&lt;U+00A0&gt;s[:]。 是 s.copy() 回報序列s淺複製的副本，等同&lt;U+00A0&gt;s[:]。 是 s.extend(t)&lt;U+00A0&gt;或&lt;U+00A0&gt;s&lt;U+00A0&gt;+=&lt;U+00A0&gt;t 將序列t展延至序列s的尾端，基本等同&lt;U+00A0&gt;s[len(s):len(s)]&lt;U+00A0&gt;=&lt;U+00A0&gt;t。 是 s&lt;U+00A0&gt;*=&lt;U+00A0&gt;n 序列s更新為原來的n次重複。 是 s.insert(i,&lt;U+00A0&gt;x) 在序列s的索引位置i處插入x元素，等同&lt;U+00A0&gt;s[i:i]&lt;U+00A0&gt;=&lt;U+00A0&gt;[x]。 是 s.pop([i]) 自序列s中取出索引位置i的元素並將其從該序列移除。 是 s.remove(x) 刪除序列s中首次出現的元素x。 是 s.reverse() 將序列s反向排列。 是 6.5 自我練習（序列型別） 打開Jupyter或Spyder。 自己建構一些範圍，列出長度、展開內容，看看與自己的預期是否相同。 自己建構一些字串，嘗試不同格式調整，善用輸入功能，改變列出結果。 使用可變的串列建構一些例子，應用前面表格中的每種序列方法，至少都試過三次， 查找自己建構的物件有哪些方法，還有哪些是沒有學過的，善用幫助help( )嘗試尋找其使用方式，動作試著使用看看。 "],
["條件陳述conditional-statements.html", "7 條件陳述（Conditional Statements） 7.1 何謂條件 7.2 if相關陳述 7.3 學習要點（條件陳述） 7.4 應用情境（條件陳述）", " 7 條件陳述（Conditional Statements） 7.1 何謂條件 在編程語言中的條件，指的是邏輯條件，也就是比較運算的結果，其為布林型別，有真（True）或假（False）二種值，為真時表示條件被滿足，為假則條件不滿足。再複習一下常見的比較運算： 等於：a == b（請注意，二個等號是測試相等與否的邏輯運算子，一個等號是指派運算子） 不等於：a != b 小於：a &lt; b 小於等於：a &lt;= b 大於：a &gt; b 大於等於：a &gt;= b 一個以上的布林值還可以用邏輯運算「且、或、非」得到單一結果，例如： 功課做完「and」家事做完，才可以玩遊戲。 數學得滿分「or」英語等滿分，都能有獎勵。 「not」家庭聯絡簿上無老師紅字，家長不開心。 7.2 if相關陳述 7.2.1 if… 陳述 這是「如果這樣，就做一些什麼」的意思，其中的「這樣」就是邏輯條件，假設「如果阿萬有了100元，他就開心」： money = 128 # 阿願最初有這麼多錢。 if money &gt;= 100: # if後面接的是邏輯條件，結果為真時，執行分號下一橫排起的陳述，下一橫排要退縮。 paragf = &quot;A1 has {} and happy&quot;.format(money) # 常見退縮四個空白。 print(paragf) # 齊頭退縮，代表相同的代碼區塊層級。 ## A1 has 128 and happy 注意，if… 陳述之下一層次的代碼，若無齊頭退縮，將會產生錯誤！ if… 陳述也可以寫成單句，如下： if money &gt;= 100: print(&quot;A1 has {} and happy&quot;.format(money)) ## A1 has 128 and happy 7.2.2 if… else… 陳述 這是「如果這樣，就做一些什麼，如果不這樣，就做另一些什麼」的意思，假設「如果阿萬有了100元，他就說他開心，如果他只有不到100元，他就不開心」： money = money - 30 # 阿萬花掉了一些錢，這句等同 money -= 30。 if money &gt;= 100: paragf = &quot;A1 has {} and happy&quot;.format(money) print(paragf) else: paragf = &quot;A1 has {} and unhappy&quot;.format(money) print(paragf) ## A1 has 98 and unhappy if… else… 陳述也可以寫成單句，如下： print(&quot;A1 has {} and happy&quot;.format(money)) if money &gt;= 100 else print(&quot;A1 has {} and unhappy&quot;.format(money)) ## A1 has 98 and unhappy 7.2.3 if… elif… else… 陳述 這是「如果這樣，就做一些什麼，如果那樣，就做另一些什麼，如果不這樣不那樣，就做其他一些什麼」的意思，假設「如果阿萬有了200元，他就會超開心，如果有了100元，他就開心，如果只有不到100元，他就不開心」： money = money + 150 # 阿萬得到一些錢，這句等同 money += 150。 if money &gt;= 200: paragf = &quot;I&#39;m A1, I have {} dollars and I&#39;m super happy&quot;.format(money) print(paragf) elif money &gt;= 100: paragf = &quot;I&#39;m A1, I have {} dollars and I&#39;m happy&quot;.format(money) print(paragf) else: paragf = &quot;I&#39;m A1, I have {} dollars and I&#39;m unhappy&quot;.format(money) print(paragf) ## I&#39;m A1, I have 248 dollars and I&#39;m super happy if… elif… else… 陳述也可以寫成單句，如下： print(&quot;A1 has {} and super happy&quot;.format(money)) if money &gt;= 200 else print(&quot;A1 has {} and happy&quot;.format(money)) if money &gt;= 100 else print(&quot;A1 has {} and unhappy&quot;.format(money)) ## A1 has 248 and super happy 請注意其「… if … else … if … else …」用法。 7.3 學習要點（條件陳述） 複習「比較運算」、「邏輯運算」。 明白「if」、「if else」、「if elif else」語法，能夠熟練使用。 7.4 應用情境（條件陳述） 請寫一段代碼，執行後會要求使用者輸入得分，依據得分列出等第： 等於100：棒 大於等於90：優 大於等於80：甲 大於等於70：乙 大於等於60：丙 小於60：嗚 修改代碼，對於負分或超過100分的，列出「？」。 "],
["迴圈loops.html", "8 迴圈（Loops） 8.1 何謂迴圈 8.2 for迴圈 8.3 while迴圈 8.4 應用情境（迴圈） 8.5 推衍（comprehension） 8.6 學習要點", " 8 迴圈（Loops） 8.1 何謂迴圈 迴圈是一段在程式中只出現一次，但可能會連續執行多次的程式碼。迴圈中的程式碼會執行特定的次數，或者是執行到特定條件成立時結束迴圈，或者是針對某一彙集中的所有項目都執行一次。 8.2 for迴圈 8.2.1 for… 陳述 for常接一個變項，該變項會依序指涉序列或彙集內之項目，如下例range(5)可展開為0, 1, 2, 3, 4五個元素，變項i會依序指涉這幾個元素。注意：迴圈內的次一層級代碼區塊，要齊頭縮排，否則會發生錯誤。 for i in range(5): print(i) ## 0 ## 1 ## 2 ## 3 ## 4 以下例子會依序列出字串、串列、字典內之項目。 seasons_string = &quot;春夏秋冬&quot; for c in seasons_string: print(c) ## 春 ## 夏 ## 秋 ## 冬 seasons_list = [&quot;春&quot;, &quot;夏&quot;, &quot;秋&quot;, &quot;冬&quot;] for s in seasons_list: print(s) ## 春 ## 夏 ## 秋 ## 冬 seasons_dict = {&quot;spring&quot;: &quot;春&quot;, &quot;summer&quot;: &quot;夏&quot;, &quot;autumn&quot;: &quot;秋&quot;, &quot;winter&quot;: &quot;冬&quot;} for k, v in seasons_dict.items(): print(k, v) ## spring 春 ## summer 夏 ## autumn 秋 ## winter 冬 迴圈最大的好處就是可以簡化代碼，試想要將一個內含多個整數元數的串列，求其內含元素的和，我們可以有幾種寫法： nums = list(range(1, 6)) # 內容為從一到五的整數。 print(nums) ## [1, 2, 3, 4, 5] sum_1 = nums[0] + nums[1] + nums[2] + nums[3] + nums[4] # 索引值為0至4 print(sum_1) ## 15 sum_2 = 0 for i in range(len(nums)): # 索引從零開始。 sum_2 = sum_2 + nums[i] print(sum_2) ## 15 sum_3 = 0 for num in nums: sum_3 = sum_3 + num print(sum_3) ## 15 sum_4 = sum(nums) print(sum_4) ## 15 以上第一個方法，利用每個位置索引取出串列中的每個項目，以多個算術運算加號逐個相加，如果串列中的項目很多，這個方法就不實用了。 以上第二個方法，在還沒計算之前先設定總和變項為零，同樣利用每個位置索引取出串列中的每個項目，但用for逐次執行將每個索引位置的值加到總和變項中，即便串列中元素很多，只要很少代碼就能得到答案。 以上第三個方法，同樣在還沒計算之前先設定總和變項為零，利用for直接逐次取出每個項目，不用索引，寫法更簡潔。 以上第四個方法，直接使用內建函式sum( )為串列中項目加總，這是最簡潔的，但它比較不容易處理以下帶有較複雜條件的情形。 8.2.2 for… if… break 陳述 有時迴圈執行到某些條件想要跳出該次迴圈「不再執行該迴圈剩下的部分」，可以加上 if… break 陳述，上例如果我們遇到項目值為4就跳出不再列出後續項目值，可以這樣寫： for num in nums: if num == 4: break print(num) ## 1 ## 2 ## 3 8.2.3 for… if… continue 陳述 有時迴圈執行到某些條件想要跳出該次迴圈「但要執行該迴圈剩下的部分」，可以加上 if… continue 陳述，上例如果我們遇到項目值為4就跳出但要列出後續項目值，可以這樣寫： for num in nums: if num == 4: continue print(num) ## 1 ## 2 ## 3 ## 5 8.3 while迴圈 8.3.1 while… 陳述 while後帶有邏輯運算式，當結果為真時執行其下一層級的代碼區塊，直至條件為假則停止執行。所有能使用for迴圈的都能改寫為while迴圈，但不是每個while迴圈都能改寫為for迴圈。 i = 0 while i &lt; len(nums): print(nums[i]) i = i + 1 # 即 i += 1 ## 1 ## 2 ## 3 ## 4 ## 5 8.3.2 while… if… break 陳述 有時迴圈執行到某些條件想要跳出該次迴圈「不再執行該迴圈剩下的部分」，可以加上 if… break 陳述，上例如果我們遇到項目值為4就跳出不再列出後續項目值，可以這樣寫： i = 0 while i &lt; len(nums): if nums[i] == 4: i = i + 1 break print(nums[i]) i = i + 1 ## 1 ## 2 ## 3 8.3.3 while… if… continue 陳述 有時迴圈執行到某些條件想要跳出該次迴圈「但要執行該迴圈剩下的部分」，可以加上 if… continue 陳述，上例如果我們遇到項目值為4就跳出但要列出後續項目值，可以這樣寫： i = 0 while i &lt; len(nums): if nums[i] == 4: i = i + 1 continue print(nums[i]) i = i + 1 ## 1 ## 2 ## 3 ## 5 8.4 應用情境（迴圈） 製作一份九九乘法表。 nums =list(range(1, 10)) for i in nums: for j in nums: print(&quot;{i} * {j} = {k}&quot;.format(i = i, j = j, k = i * j)) ## 1 * 1 = 1 ## 1 * 2 = 2 ## 1 * 3 = 3 ## 1 * 4 = 4 ## 1 * 5 = 5 ## 1 * 6 = 6 ## 1 * 7 = 7 ## 1 * 8 = 8 ## 1 * 9 = 9 ## 2 * 1 = 2 ## 2 * 2 = 4 ## 2 * 3 = 6 ## 2 * 4 = 8 ## 2 * 5 = 10 ## 2 * 6 = 12 ## 2 * 7 = 14 ## 2 * 8 = 16 ## 2 * 9 = 18 ## 3 * 1 = 3 ## 3 * 2 = 6 ## 3 * 3 = 9 ## 3 * 4 = 12 ## 3 * 5 = 15 ## 3 * 6 = 18 ## 3 * 7 = 21 ## 3 * 8 = 24 ## 3 * 9 = 27 ## 4 * 1 = 4 ## 4 * 2 = 8 ## 4 * 3 = 12 ## 4 * 4 = 16 ## 4 * 5 = 20 ## 4 * 6 = 24 ## 4 * 7 = 28 ## 4 * 8 = 32 ## 4 * 9 = 36 ## 5 * 1 = 5 ## 5 * 2 = 10 ## 5 * 3 = 15 ## 5 * 4 = 20 ## 5 * 5 = 25 ## 5 * 6 = 30 ## 5 * 7 = 35 ## 5 * 8 = 40 ## 5 * 9 = 45 ## 6 * 1 = 6 ## 6 * 2 = 12 ## 6 * 3 = 18 ## 6 * 4 = 24 ## 6 * 5 = 30 ## 6 * 6 = 36 ## 6 * 7 = 42 ## 6 * 8 = 48 ## 6 * 9 = 54 ## 7 * 1 = 7 ## 7 * 2 = 14 ## 7 * 3 = 21 ## 7 * 4 = 28 ## 7 * 5 = 35 ## 7 * 6 = 42 ## 7 * 7 = 49 ## 7 * 8 = 56 ## 7 * 9 = 63 ## 8 * 1 = 8 ## 8 * 2 = 16 ## 8 * 3 = 24 ## 8 * 4 = 32 ## 8 * 5 = 40 ## 8 * 6 = 48 ## 8 * 7 = 56 ## 8 * 8 = 64 ## 8 * 9 = 72 ## 9 * 1 = 9 ## 9 * 2 = 18 ## 9 * 3 = 27 ## 9 * 4 = 36 ## 9 * 5 = 45 ## 9 * 6 = 54 ## 9 * 7 = 63 ## 9 * 8 = 72 ## 9 * 9 = 81 有一個串列內含整數一至十，請將該串列中項目為奇數者放在一個新的串列，項目為偶數者放在另一個新的串列，並分別列出這二個新的串列。 nums =list(range(1, 11)) odd = [] even = [] while len(nums) &gt; 0: num = nums.pop(0) if num % 2 == 0: even.append(num) else: odd.append(num) print(odd) ## [1, 3, 5, 7, 9] print(even) ## [2, 4, 6, 8, 10] 8.5 推衍（comprehension） 我們之前學了串列（list）和字典（dictionary），也學了for、if陳述，現在我們可以利用它們來建構推衍。 8.5.1 串列推衍（list comprehension） 以一個既有的整數串列為基礎，建構一個新的串列，其中每個項目是既有串列項目加一： nums =list(range(1, 11)) print(nums) ## [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] newlist_1 = [x + 1 for x in nums] print(newlist_1) ## [2, 3, 4, 5, 6, 7, 8, 9, 10, 11] 以一個既有的整數串列為基礎，建構一個新的串列，其中每個項目是既有串列項目平方： newlist_2 = [x ** 2 for x in nums] print(newlist_2) ## [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 同上，但只要既有串列項目是奇數的平方項目： newlist_3 = [x ** 2 for x in nums if x % 2 != 0] print(newlist_3) ## [1, 9, 25, 49, 81] 同上，但限制新串列的項目是偶數： newlist_4 = [x ** 2 for x in nums if x ** 2 % 2 == 0] print(newlist_4) ## [4, 16, 36, 64, 100] 8.5.2 字典推衍（dictionary comprehension） 以一個既有的整數串列為基礎，建構一個新的字典，鍵用原串列項目，值用原串列項目的平方： nums =list(range(1, 6)) print(nums) ## [1, 2, 3, 4, 5] newdict_1 = {x:x**2 for x in nums} print(newdict_1) ## {1: 1, 2: 4, 3: 9, 4: 16, 5: 25} 以一個既有的字串串列為基礎，排除原串列部分項目，建構一個新的字典，鍵用原串列項目，值用原串列項目的字串長度： foods = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;, &quot;noodle&quot;, &quot;rice&quot;] newdict_2 = {f:len(f) for f in foods if (f != &quot;noodle&quot; and f != &quot;rice&quot;)} print(newdict_2) ## {&#39;apple&#39;: 5, &#39;banana&#39;: 6, &#39;cherry&#39;: 6} 8.6 學習要點 瞭解for…、for… if… break…、for… if… continue…的用法。 瞭解while…、while… if… break…、while… if… continue…的用法。 瞭解串列推衍（list comprehension）的用法。 瞭解字典推衍（dictionary comprehension）的用法。 "],
["函式functions.html", "9 函式（Functions） 9.1 何謂函式 9.2 為何需要函式 9.3 函式建構 9.4 函式建構範例", " 9 函式（Functions） 9.1 何謂函式 我們已經學過好多函式了，例如一開始的print( )、help( )，再來如求取長度的len( )、找最大值的max( )、找最小值的min( )、計算總和的sum( )等，都是函式，有些函式附屬在某類型別的物件上，又稱為方法，如之前學過字串物件的方法有upper( )、lower( )或串列物件的方法有append( )、extend( )等。 9.2 為何需要函式 假設我們想讓電腦說一句話，可以這樣： print(&quot;Hi, there&quot;) ## Hi, there 如果我們要讓電腦說同一句話三次，可以這樣： print(&quot;Hi, there&quot;) ## Hi, there print(&quot;Hi, there&quot;) ## Hi, there print(&quot;Hi, there&quot;) ## Hi, there 但如果同一句話要說十次、百次、千次、萬次怎麼辦呢？這時除了可以利用迴圈之外，主要利用函式是用來執行某些重複動作，還可以依據每次執行的需要，變更執行內容。 9.3 函式建構 9.3.1 無輸入值 承上，例如我們先用一個函式讓電腦同一句話說三次，用def來定義函式，後接函式名稱與小括弧，冒號之後的次一層級代碼區塊要齊頭縮排： def sayhi(): # 利用def來定義函式。 for i in range(3): print(&quot;Hi, there&quot;) sayhi() ## Hi, there ## Hi, there ## Hi, there 9.3.2 有輸入值，但無輸入預設值 承上，如果我們要讓同一句話說n次，假設n是2次的話，可以這樣： def sayhi(n): # 這利用n代表次數，可讓使用者輸入。 for i in range(n): print(&quot;Hi, there&quot;) sayhi(2) ## Hi, there ## Hi, there 如果使用者不輸入n的話，發生錯誤： sayhi() ## Error in py_call_impl(callable, dots$args, dots$keywords): TypeError: sayhi() missing 1 required positional argument: &#39;n&#39; ## ## Detailed traceback: ## File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt; 9.3.3 有輸入值，也有輸入預設值 我們可以為輸入值安排預設值，當無輸入值時仍可以運作，下例n之預設值為1次： def sayhi(n = 1): for i in range(n): print(&quot;Hi, there&quot;) sayhi() # 沒有輸入值，n預設為1，只列出一次。 ## Hi, there 承上，如果我們鰾讓同一句話對某人someone說n次，假設n是3次，某人名字是John的話，兩者都有預設值，可以這樣： def sayhi(n = 1, someone = &quot;my friend&quot;): for i in range(n): print(&quot;Hi, {}&quot;.format(someone)) sayhi(3, &quot;John&quot;) ## Hi, John ## Hi, John ## Hi, John sayhi() # n預設為一次，someone預設為&quot;my friend&quot;。 ## Hi, my friend 這樣使用函式（或物件的方法）是不是比單純的迴圈靈活很多啊！ 9.4 函式建構範例 找出一段文字中的每一單字出現次數，輸入為一個長的字串，輸出為一個字典，其鍵為各單字、值為該單字出現次數。打算要輸入的字串如下： # 每一橫排最後的反斜線「\\」代表接續至下一橫排的意思。 zen = &quot;Beautiful is better than ugly.\\ Explicit is better than implicit.\\ Simple is better than complex.\\ Complex is better than complicated.\\ Flat is better than nested.\\ Sparse is better than dense.\\ Readability counts.\\ Special cases aren&#39;t special enough to break the rules.\\ Although practicality beats purity.\\ Errors should never pass silently.\\ Unless explicitly silenced.\\ In the face of ambiguity, refuse the temptation to guess.\\ There should be one-- and preferably only one --obvious way to do it.\\ Although that way may not be obvious at first unless you&#39;re Dutch.\\ Now is better than never.\\ Although never is often better than *right* now.\\ If the implementation is hard to explain, it&#39;s a bad idea.\\ If the implementation is easy to explain, it may be a good idea.\\ Namespaces are one honking great idea -- let&#39;s do more of those!&quot; print(zen) ## Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Flat is better than nested. Sparse is better than dense. Readability counts. Special cases aren&#39;t special enough to break the rules. Although practicality beats purity. Errors should never pass silently. Unless explicitly silenced. In the face of ambiguity, refuse the temptation to guess. There should be one-- and preferably only one --obvious way to do it. Although that way may not be obvious at first unless you&#39;re Dutch. Now is better than never. Although never is often better than *right* now. If the implementation is hard to explain, it&#39;s a bad idea. If the implementation is easy to explain, it may be a good idea. Namespaces are one honking great idea -- let&#39;s do more of those! 我們先嘗試將字串拆分為單字組成的串列： # 整理字串內容以移除特殊符號，全部改成小寫後，拆分為單字串列。 zen = zen.replace(&quot;.&quot;, &quot; &quot;) # 移除句點。 zen = zen.replace(&quot;,&quot;, &quot; &quot;) # 移除逗點。 zen = zen.replace(&quot;-&quot;, &quot; &quot;) # 移除減號。 zen = zen.replace(&quot;&#39;&quot;, &quot;&quot;) # 移除撇號。 zen = zen.replace(&quot;*&quot;, &quot;&quot;) # 移除星號。 zen = zen.lower().split() # 改成小寫，拆分成為串列。 print(zen) # 列出串列查看。 ## [&#39;beautiful&#39;, &#39;is&#39;, &#39;better&#39;, &#39;than&#39;, &#39;ugly&#39;, &#39;explicit&#39;, &#39;is&#39;, &#39;better&#39;, &#39;than&#39;, &#39;implicit&#39;, &#39;simple&#39;, &#39;is&#39;, &#39;better&#39;, &#39;than&#39;, &#39;complex&#39;, &#39;complex&#39;, &#39;is&#39;, &#39;better&#39;, &#39;than&#39;, &#39;complicated&#39;, &#39;flat&#39;, &#39;is&#39;, &#39;better&#39;, &#39;than&#39;, &#39;nested&#39;, &#39;sparse&#39;, &#39;is&#39;, &#39;better&#39;, &#39;than&#39;, &#39;dense&#39;, &#39;readability&#39;, &#39;counts&#39;, &#39;special&#39;, &#39;cases&#39;, &#39;arent&#39;, &#39;special&#39;, &#39;enough&#39;, &#39;to&#39;, &#39;break&#39;, &#39;the&#39;, &#39;rules&#39;, &#39;although&#39;, &#39;practicality&#39;, &#39;beats&#39;, &#39;purity&#39;, &#39;errors&#39;, &#39;should&#39;, &#39;never&#39;, &#39;pass&#39;, &#39;silently&#39;, &#39;unless&#39;, &#39;explicitly&#39;, &#39;silenced&#39;, &#39;in&#39;, &#39;the&#39;, &#39;face&#39;, &#39;of&#39;, &#39;ambiguity&#39;, &#39;refuse&#39;, &#39;the&#39;, &#39;temptation&#39;, &#39;to&#39;, &#39;guess&#39;, &#39;there&#39;, &#39;should&#39;, &#39;be&#39;, &#39;one&#39;, &#39;and&#39;, &#39;preferably&#39;, &#39;only&#39;, &#39;one&#39;, &#39;obvious&#39;, &#39;way&#39;, &#39;to&#39;, &#39;do&#39;, &#39;it&#39;, &#39;although&#39;, &#39;that&#39;, &#39;way&#39;, &#39;may&#39;, &#39;not&#39;, &#39;be&#39;, &#39;obvious&#39;, &#39;at&#39;, &#39;first&#39;, &#39;unless&#39;, &#39;youre&#39;, &#39;dutch&#39;, &#39;now&#39;, &#39;is&#39;, &#39;better&#39;, &#39;than&#39;, &#39;never&#39;, &#39;although&#39;, &#39;never&#39;, &#39;is&#39;, &#39;often&#39;, &#39;better&#39;, &#39;than&#39;, &#39;right&#39;, &#39;now&#39;, &#39;if&#39;, &#39;the&#39;, &#39;implementation&#39;, &#39;is&#39;, &#39;hard&#39;, &#39;to&#39;, &#39;explain&#39;, &#39;its&#39;, &#39;a&#39;, &#39;bad&#39;, &#39;idea&#39;, &#39;if&#39;, &#39;the&#39;, &#39;implementation&#39;, &#39;is&#39;, &#39;easy&#39;, &#39;to&#39;, &#39;explain&#39;, &#39;it&#39;, &#39;may&#39;, &#39;be&#39;, &#39;a&#39;, &#39;good&#39;, &#39;idea&#39;, &#39;namespaces&#39;, &#39;are&#39;, &#39;one&#39;, &#39;honking&#39;, &#39;great&#39;, &#39;idea&#39;, &#39;lets&#39;, &#39;do&#39;, &#39;more&#39;, &#39;of&#39;, &#39;those!&#39;] 再來建構所需函式內容： def word_freq(word_list): if word_list is None: # 如果輸入值為空無。 return None # 回報值為空無。 else: # 如果輸入值不是空無。 out = {} # 建構一預備輸出的空字典。 for word in word_list: if word in out: # 如果該單字已在字典中。 out[word] = out[word] + 1 # 該單字對應的值加一。 else: # 如果該單字不在字典中 out[word] = 1 # 該單字對應的值為一。 return out 執行函式查看結果： out_dict = word_freq(zen) print(out_dict) ## {&#39;beautiful&#39;: 1, &#39;is&#39;: 10, &#39;better&#39;: 8, &#39;than&#39;: 8, &#39;ugly&#39;: 1, &#39;explicit&#39;: 1, &#39;implicit&#39;: 1, &#39;simple&#39;: 1, &#39;complex&#39;: 2, &#39;complicated&#39;: 1, &#39;flat&#39;: 1, &#39;nested&#39;: 1, &#39;sparse&#39;: 1, &#39;dense&#39;: 1, &#39;readability&#39;: 1, &#39;counts&#39;: 1, &#39;special&#39;: 2, &#39;cases&#39;: 1, &#39;arent&#39;: 1, &#39;enough&#39;: 1, &#39;to&#39;: 5, &#39;break&#39;: 1, &#39;the&#39;: 5, &#39;rules&#39;: 1, &#39;although&#39;: 3, &#39;practicality&#39;: 1, &#39;beats&#39;: 1, &#39;purity&#39;: 1, &#39;errors&#39;: 1, &#39;should&#39;: 2, &#39;never&#39;: 3, &#39;pass&#39;: 1, &#39;silently&#39;: 1, &#39;unless&#39;: 2, &#39;explicitly&#39;: 1, &#39;silenced&#39;: 1, &#39;in&#39;: 1, &#39;face&#39;: 1, &#39;of&#39;: 2, &#39;ambiguity&#39;: 1, &#39;refuse&#39;: 1, &#39;temptation&#39;: 1, &#39;guess&#39;: 1, &#39;there&#39;: 1, &#39;be&#39;: 3, &#39;one&#39;: 3, &#39;and&#39;: 1, &#39;preferably&#39;: 1, &#39;only&#39;: 1, &#39;obvious&#39;: 2, &#39;way&#39;: 2, &#39;do&#39;: 2, &#39;it&#39;: 2, &#39;that&#39;: 1, &#39;may&#39;: 2, &#39;not&#39;: 1, &#39;at&#39;: 1, &#39;first&#39;: 1, &#39;youre&#39;: 1, &#39;dutch&#39;: 1, &#39;now&#39;: 2, &#39;often&#39;: 1, &#39;right&#39;: 1, &#39;if&#39;: 2, &#39;implementation&#39;: 2, &#39;hard&#39;: 1, &#39;explain&#39;: 2, &#39;its&#39;: 1, &#39;a&#39;: 2, &#39;bad&#39;: 1, &#39;idea&#39;: 3, &#39;easy&#39;: 1, &#39;good&#39;: 1, &#39;namespaces&#39;: 1, &#39;are&#39;: 1, &#39;honking&#39;: 1, &#39;great&#39;: 1, &#39;lets&#39;: 1, &#39;more&#39;: 1, &#39;those!&#39;: 1} 這樣的結果，沒有依照單字出現次數由多到少排列，我們接著調整一下結果，改為鍵值對的元組的串列，其值由大至小排列： out_list = sorted(out_dict.items(), key = lambda d: d[1], reverse = True) # 依元組中值的大小降冪排列。 print(out_list) ## [(&#39;is&#39;, 10), (&#39;better&#39;, 8), (&#39;than&#39;, 8), (&#39;to&#39;, 5), (&#39;the&#39;, 5), (&#39;although&#39;, 3), (&#39;never&#39;, 3), (&#39;be&#39;, 3), (&#39;one&#39;, 3), (&#39;idea&#39;, 3), (&#39;complex&#39;, 2), (&#39;special&#39;, 2), (&#39;should&#39;, 2), (&#39;unless&#39;, 2), (&#39;of&#39;, 2), (&#39;obvious&#39;, 2), (&#39;way&#39;, 2), (&#39;do&#39;, 2), (&#39;it&#39;, 2), (&#39;may&#39;, 2), (&#39;now&#39;, 2), (&#39;if&#39;, 2), (&#39;implementation&#39;, 2), (&#39;explain&#39;, 2), (&#39;a&#39;, 2), (&#39;beautiful&#39;, 1), (&#39;ugly&#39;, 1), (&#39;explicit&#39;, 1), (&#39;implicit&#39;, 1), (&#39;simple&#39;, 1), (&#39;complicated&#39;, 1), (&#39;flat&#39;, 1), (&#39;nested&#39;, 1), (&#39;sparse&#39;, 1), (&#39;dense&#39;, 1), (&#39;readability&#39;, 1), (&#39;counts&#39;, 1), (&#39;cases&#39;, 1), (&#39;arent&#39;, 1), (&#39;enough&#39;, 1), (&#39;break&#39;, 1), (&#39;rules&#39;, 1), (&#39;practicality&#39;, 1), (&#39;beats&#39;, 1), (&#39;purity&#39;, 1), (&#39;errors&#39;, 1), (&#39;pass&#39;, 1), (&#39;silently&#39;, 1), (&#39;explicitly&#39;, 1), (&#39;silenced&#39;, 1), (&#39;in&#39;, 1), (&#39;face&#39;, 1), (&#39;ambiguity&#39;, 1), (&#39;refuse&#39;, 1), (&#39;temptation&#39;, 1), (&#39;guess&#39;, 1), (&#39;there&#39;, 1), (&#39;and&#39;, 1), (&#39;preferably&#39;, 1), (&#39;only&#39;, 1), (&#39;that&#39;, 1), (&#39;not&#39;, 1), (&#39;at&#39;, 1), (&#39;first&#39;, 1), (&#39;youre&#39;, 1), (&#39;dutch&#39;, 1), (&#39;often&#39;, 1), (&#39;right&#39;, 1), (&#39;hard&#39;, 1), (&#39;its&#39;, 1), (&#39;bad&#39;, 1), (&#39;easy&#39;, 1), (&#39;good&#39;, 1), (&#39;namespaces&#39;, 1), (&#39;are&#39;, 1), (&#39;honking&#39;, 1), (&#39;great&#39;, 1), (&#39;lets&#39;, 1), (&#39;more&#39;, 1), (&#39;those!&#39;, 1)] "],
["模組modules.html", "10 模組（Modules） 10.1 何謂模組 10.2 模組建構 10.3 模組使用 10.4 學習要點（模組） 10.5 自我練習（模組）", " 10 模組（Modules） 10.1 何謂模組 模組就是一個python檔案，是以「.py」結尾的代碼文字檔案，可在其中定義變項、函式、類別等，把相關代碼放到同一模組，能更方便管理。 10.2 模組建構 因為模組就是python檔案，當我們寫了幾個函式，準備以後用在不同場合，可以先將這些函式放到一個檔案中，比如我們現在先製作幾個函式備用，再將這些函式代碼，起個檔名假設叫「mz.py」存起來，這個檔案是個模組了。 def max_2(a, b): if a &gt; b: return a else: return b def min_2(a, b): if a &lt; b: return a else: return b def add_2(a, b): return a + b def sub_2(a, b): return a - b def mul_2(a, b): return a * b def div_2(a, b): return a / b 存檔的方法可以是直接使用整合開發環境Spyder的「File &gt; Save as」功能，輸入要存檔的名稱。也可以將以上函式直接以多排字串型別命名成變項，以下假設叫做funcs，再寫入模組中，如下： with open(&#39;mz.py&#39;, &#39;w&#39;) as f: f.write(funcs) 10.3 模組使用 假設我們所在工作目錄中存在「mz.py」這個模組，那麼我們要使用時，可以先用import再接模組名稱（即檔名不含py後綴部分，可包括檔案所在目錄位置）陳述，接著就能使用其中的函式囉： import mz print(mz.max_2(3, 5)) print(mz.min_2(3, 5)) print(mz.add_2(3, 5)) print(mz.sub_2(3, 5)) print(mz.mul_2(3, 5)) print(mz.div_2(3, 5)) 除了使用者自己製作的模組之外，python自身本來就帶有許多模組，詳細可參考Python Module Index，我們以其中可產生亂數的random模組為例，要使用其中的choice函式，從某序列中隨機選出一個元素，因為是隨機的，每次結果不一定相同。 import random print(random.choice(&quot;木火土金水&quot;)) ## 土 10.4 學習要點（模組） 明白模組的意義，並能自己製作模組。 明白如何使用模組，包括python自帶的及使用者所定義的。 10.5 自我練習（模組） 使用內建的數學（math）模組的最大公因數函式（gcd( )），自己設定幾組任意二個整數找出它們的最大公因素，如果不知道使用方法，可利用help( )查找。 "],
["電子郵件emails.html", "11 電子郵件（EMails） 11.1 寄發郵件", " 11 電子郵件（EMails） 11.1 寄發郵件 寄發郵件主要使用 smtp 協定。 import smtplib from email.mime.multipart import MIMEMultipart from email.mime.text import MIMEText from email.mime.image import MIMEImage # Microsoft Outlook uses &#39;smtp-mail.outlook.com&#39; as server. smtp = smtplib.SMTP(&#39;smtp.gmail.com&#39;, 587) # create a SMTP instance. smtp.ehlo() # say hello to the server. ## (250, b&#39;smtp.gmail.com at your service, [2001:b400:e338:707d:7527:5739:bd86:dadb]\\nSIZE 35882577\\n8BITMIME\\nSTARTTLS\\nENHANCEDSTATUSCODES\\nPIPELINING\\nCHUNKING\\nSMTPUTF8&#39;) smtp.starttls() # set connection in Transport Layer Security mode. ## (220, b&#39;2.0.0 Ready to start TLS&#39;) smtp.login(id, pw) # use your own id and password to login. ## Error in py_call_impl(callable, dots$args, dots$keywords): SMTPAuthenticationError: (535, b&#39;5.7.8 Username and Password not accepted. Learn more at\\n5.7.8 https://support.google.com/mail/?p=BadCredentials x5sm2601625pfj.1 - gsmtp&#39;) ## ## Detailed traceback: ## File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt; ## File &quot;D:\\Program_Files\\Anaconda3\\lib\\smtplib.py&quot;, line 730, in login ## raise last_exception ## File &quot;D:\\Program_Files\\Anaconda3\\lib\\smtplib.py&quot;, line 721, in login ## initial_response_ok=initial_response_ok) ## File &quot;D:\\Program_Files\\Anaconda3\\lib\\smtplib.py&quot;, line 642, in auth ## raise SMTPAuthenticationError(code, resp) 準備郵件內容。 msg = MIMEMultipart(&#39;alternative&#39;) msg[&#39;From&#39;] = &#39;no.id@m2k.com.tw&#39; msg[&#39;To&#39;] = &#39;un.known@m2k.com.tw&#39; msg[&#39;Cc&#39;] = &#39;fake.user@m2k.com.tw&#39; msg[&#39;Subject&#39;] = &quot;TestMail&quot; txt = &quot;plain text&quot; htm = &quot;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;html text&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&quot; part1 = MIMEText(txt, &#39;plain&#39;, &#39;utf-8&#39;) part2 = MIMEText(htm, &#39;html&#39;, &#39;utf-8&#39;) msg.attach(part1) msg.attach(part2) # att = MIMEText(open(&#39;./img/python.png&#39;, &#39;rb&#39;).read(), &#39;base64&#39;, &#39;utf-8&#39;) att = MIMEImage(open(&#39;./img/python.png&#39;, &#39;rb&#39;).read()) att[&quot;Content-Type&quot;] = &#39;application/octet-stream&#39; att[&quot;Content-Disposition&quot;] = &#39;attachment; filename=&quot;pyicon.png&quot;&#39; msg.attach(att) 寄出後結束連線。 # return an empty dict if success. smtp.sendmail(from_addr = &quot;Sender&quot;, to_addrs = &quot;test.user@m2k.com.tw&quot;, msg = msg.as_string()) ## Error in py_call_impl(callable, dots$args, dots$keywords): SMTPSenderRefused: (530, b&#39;5.7.0 Authentication Required. Learn more at\\n5.7.0 https://support.google.com/mail/?p=WantAuthError x5sm2601625pfj.1 - gsmtp&#39;, &#39;Sender&#39;) ## ## Detailed traceback: ## File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt; ## File &quot;D:\\Program_Files\\Anaconda3\\lib\\smtplib.py&quot;, line 867, in sendmail ## raise SMTPSenderRefused(code, resp, from_addr) smtp.quit() ## (221, b&#39;2.0.0 closing connection x5sm2601625pfj.1 - gsmtp&#39;) "]
]
